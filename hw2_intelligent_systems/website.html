<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Othello AI Arena (HW2 - GIST AGI25sp)</title>
    <style>
        /* Basic Styles */
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
            background-color: #f0f0f0;
        }

        h1,
        h3,
        h4 {
            margin-top: 0;
            margin-bottom: 15px;
        }

        button {
            background: #4CAF50;
            color: white;
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background: #45a049;
        }

        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        select,
        input[type="text"] {
            width: calc(100% - 12px);
            padding: 8px;
            margin: 5px 0 10px 0;
            border-radius: 4px;
            border: 1px solid #ddd;
            box-sizing: border-box;
        }

        textarea {
            width: 100%;
            height: 300px;
            font-family: monospace;
            font-size: 14px;
            margin-bottom: 10px;
            resize: vertical;
            border: 1px solid #ddd;
            padding: 10px;
            box-sizing: border-box;
        }

        /* Layout */
        .container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 20px;
            flex-wrap: wrap;
        }

        .game-container,
        .code-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 420px;
        }

        .game-container {
            align-items: center;
        }

        .code-container {
            text-align: left;
        }

        /* Game Board */
        .board {
            display: grid;
            gap: 1px;
            background: #000;
            padding: 4px;
            margin-bottom: 20px;
            border: 2px solid #333;
        }

        .cell {
            background: #1e8d1e;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: default;
            /* Default cursor */
            position: relative;
        }

        .cell.playable {
            cursor: pointer;
        }

        /* Cursor for human playable cells */
        .cell.blocked {
            background: #555;
            cursor: not-allowed;
        }

        .disc {
            width: 80%;
            height: 80%;
            border-radius: 50%;
        }

        .disc.black {
            background: #000;
            border: 1px solid #333;
        }

        .disc.white {
            background: #fff;
            border: 1px solid #ccc;
        }

        .cell.valid-move-hint::after {
            /* Hint for valid moves */
            content: '';
            display: block;
            width: 20%;
            height: 20%;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            position: absolute;
        }

        /* Controls & Info */
        .controls {
            margin: 10px 0;
            width: 100%;
            max-width: 410px;
            background: #eee;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }

        .controls div {
            margin-bottom: 10px;
        }

        .controls label {
            margin-right: 5px;
            font-weight: bold;
            display: inline-block;
            min-width: 60px;
        }

        .controls select {
            width: calc(100% - 75px);
            display: inline-block;
        }

        .controls button {
            margin-top: 10px;
        }

        .info-panel {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 410px;
            margin-bottom: 10px;
        }

        .score-box {
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            background: #eee;
        }

        .score-box.black {
            border-left: 4px solid #000;
        }

        .score-box.white {
            border-right: 4px solid #000;
        }

        .timer-panel {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 410px;
            margin-bottom: 10px;
        }

        .timer {
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            background: #eee;
        }

        .timer.black {
            border-left: 4px solid #000;
        }

        .timer.white {
            border-right: 4px solid #000;
        }

        .timer.warning {
            background-color: #fff3cd;
            color: #856404;
        }

        .timer.danger {
            background-color: #f8d7da;
            color: #721c24;
        }

        .status {
            background: #4CAF50;
            color: white;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 4px;
            width: 100%;
            max-width: 410px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .status.thinking {
            background-color: #FFC107;
            color: #000;
        }

        /* Thinking status color */
        .status.error {
            background-color: #f44336;
        }

        /* Error status color */


        /* Log & Strategy Management */
        .game-log {
            max-height: 150px;
            overflow-y: auto;
            width: 100%;
            max-width: 410px;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 10px;
            text-align: left;
            font-family: monospace;
            font-size: 12px;
            background: #fff;
        }

        .strategy-buttons {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .saved-strategies {
            margin-top: 10px;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            background: #fff;
        }

        .strategy-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #eee;
        }

        .strategy-item:last-child {
            border-bottom: none;
        }

        .strategy-item .buttons button {
            padding: 5px 10px;
            margin: 0 3px;
            font-size: 12px;
        }

        .delete-btn {
            background-color: #f44336;
        }

        .delete-btn:hover {
            background-color: #d32f2f;
        }

        .strategy-upload {
            margin-top: 15px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
        }

        #strategy-file-input {
            margin-bottom: 10px;
            width: 100%;
        }

        .upload-status {
            margin-top: 10px;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 14px;
        }

        .upload-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .upload-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .intelligent-system-upload {
            margin-top: 15px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f0f8ff;
            border-left: 4px solid #1e90ff;
        }

        .intelligent-system-upload h4 {
            color: #1e90ff;
            margin-top: 0;
        }

        .intelligent-system-progress {
            margin-top: 10px;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            display: none;
        }

        .intelligent-system-progress-bar {
            height: 100%;
            background-color: #1e90ff;
            border-radius: 10px;
            width: 0%;
            transition: width 0.5s;
        }

        .intelligent-system-status {
            margin-top: 10px;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 14px;
            display: none;
        }

        /* Leaderboard */
        .leaderboard-container {
            margin-top: 20px;
            width: 100%;
            max-width: 410px;
        }

        #leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            background: #fff;
        }

        #leaderboard-table th,
        #leaderboard-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        #leaderboard-table th {
            background-color: #4CAF50;
            color: white;
        }

        #leaderboard-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        .tournament-btn {
            margin-bottom: 10px;
            width: 40%;
        }

        #tournament-status {
            margin: 10px 0;
            padding: 8px;
            background-color: #f1f1f1;
            border-radius: 4px;
            text-align: center;
        }

        .rollout-controls {
            margin: 10px 0;
            width: 100%;
            max-width: 410px;
            background: #eee;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }

        .rollout-display {
            margin-bottom: 10px;
            font-weight: bold;
            text-align: center;
            padding: 5px;
            background: #f8f8f8;
            border-radius: 3px;
        }

        .rollout-buttons {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }

        .rollout-buttons button {
            width: 40px;
            height: 40px;
            margin: 0 5px;
            font-size: 16px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rollout-sliders {
            margin-bottom: 15px;
        }

        .rollout-sliders label {
            display: block;
            margin-bottom: 8px;
            font-weight: normal;
        }

        .rollout-sliders input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .log-controls {
            display: flex;
            flex-direction: column;
            border-top: 1px solid #ddd;
            padding-top: 15px;
        }

        .log-controls button {
            margin-bottom: 10px;
            width: 40%;
            display: inline-block;
        }

        #log-input {
            height: 80px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }

        #rollout-prev-game,
        #rollout-next-game {
            font-weight: bold;
            font-size: 18px;
            background-color: #3a8a3a;
        }

        #game-counter {
            margin-left: 10px;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>

<body>
    <h1>Othello AI Arena (With multiple stages)</h1>

    <div class="container">
        <div class="game-container">
            <div class="info-panel">
                <div class="score-box black">Black: <span id="black-score">2</span></div>
                <div class="score-box white">White: <span id="white-score">2</span></div>
            </div>
            <div class="timer-panel">
                <div class="timer black">Black: <span id="black-timer">0.89s</span> / 10.00s</div>
                <div class="timer white">White: <span id="white-timer">0.00s</span> / 10.00s</div>
            </div>
            <div class="status thinking" id="status" style="background-color: rgb(76, 175, 80);">Stage selected. Click Start Game button.</div>
            <div class="board" id="board" style="grid-template-columns: repeat(6, 50px); grid-template-rows: repeat(6, 50px); width: 313px; height: 313px;"><div class="cell" data-row="0" data-col="0" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="0" data-col="1" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="0" data-col="2" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="0" data-col="3" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="0" data-col="4" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="0" data-col="5" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="1" data-col="0" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="1" data-col="1" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="1" data-col="2" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="1" data-col="3" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="1" data-col="4" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="1" data-col="5" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="2" data-col="0" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="2" data-col="1" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="2" data-col="2" style="width: 50px; height: 50px; cursor: default;"><div class="disc white"></div></div><div class="cell" data-row="2" data-col="3" style="width: 50px; height: 50px; cursor: default;"><div class="disc black"></div></div><div class="cell" data-row="2" data-col="4" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="2" data-col="5" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="3" data-col="0" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="3" data-col="1" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="3" data-col="2" style="width: 50px; height: 50px; cursor: default;"><div class="disc black"></div></div><div class="cell" data-row="3" data-col="3" style="width: 50px; height: 50px; cursor: default;"><div class="disc white"></div></div><div class="cell" data-row="3" data-col="4" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="3" data-col="5" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="4" data-col="0" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="4" data-col="1" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="4" data-col="2" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="4" data-col="3" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="4" data-col="4" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="4" data-col="5" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="5" data-col="0" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="5" data-col="1" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="5" data-col="2" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="5" data-col="3" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="5" data-col="4" style="width: 50px; height: 50px; cursor: default;"></div><div class="cell" data-row="5" data-col="5" style="width: 50px; height: 50px; cursor: default;"></div></div>

            <div class="controls">
                <div>
                    <label for="stageSelect">Stage:</label>
                    <select id="stageSelect"><option value="0">1: Standard 8x8</option><option value="1">2: Small Board (6x6)</option><option value="2">3: 8x8 (Partial C-Squares-cw)</option></select>
                </div>
                <div>
                    <label for="black-ai">Black:</label> <select id="black-ai"><option value="human">Human</option><optgroup label="Built-in AI"><option value="corners">Corners</option><option value="greedy">Greedy</option><option value="positional">Positional</option><option value="random">Random</option></optgroup><optgroup label="Custom Strategies"><option value="custom_mcts_0.025">mcts_0.025</option><option value="custom_mcts_0.05">mcts_0.05</option></optgroup></select>
                </div>
                <div>
                    <label for="white-ai">White:</label> <select id="white-ai"><option value="human">Human</option><optgroup label="Built-in AI"><option value="corners">Corners</option><option value="greedy">Greedy</option><option value="positional">Positional</option><option value="random">Random</option></optgroup><optgroup label="Custom Strategies"><option value="custom_mcts_0.025">mcts_0.025</option><option value="custom_mcts_0.05">mcts_0.05</option></optgroup></select>
                </div>
                <div>
                    <button id="start-btn">Start Game</button>
                    <button id="reset-btn">Reset Board</button>
                </div>
            </div>

            <!-- Roll-out Controls -->
            <div class="rollout-controls">
                <h4>Game Replay</h4>
                <div class="rollout-display">
                    <span id="rollout-progress">Turn 0/60</span>
                    <span id="game-counter">(Game 1/1)</span>
                </div>
                <div class="rollout-buttons">
                    <button id="rollout-prev-game" disabled="">◀◀</button>
                    <button id="rollout-prev">◀</button>
                    <button id="rollout-play">▶</button>
                    <button id="rollout-pause" disabled="">⏸</button>
                    <button id="rollout-stop">⏹</button>
                    <button id="rollout-next">▶</button>
                    <button id="rollout-next-game" disabled="">▶▶</button>
                </div>
                <div class="rollout-sliders">
                    <label>
                        Move:
                        <input type="range" id="rollout-moves" min="-1" max="59" value="0">
                    </label>
                    <label>
                        Speed:
                        <input type="range" id="rollout-speed" min="1" max="10" value="3">
                    </label>
                </div>
                <div class="log-controls">
                    <button id="save-log">Save Log</button>
                    <textarea id="log-input" placeholder="Game log data"></textarea>
                </div>
            </div>

            <div class="game-log" id="game-log">Game started: mcts_0.025(B) vs Corners(W) on Stage: Standard 8x8<br>mcts_0.025(B): d3<br>Corners(W): c3<br>mcts_0.025(B): e6<br>Corners(W): d2<br>mcts_0.025(B): c4<br>Corners(W): d6<br>mcts_0.025(B): e2<br>Corners(W): f4<br>mcts_0.025(B): d1<br>Corners(W): e1<br>mcts_0.025(B): f1<br>Corners(W): c2<br>mcts_0.025(B): b3<br>Corners(W): a2<br>mcts_0.025(B): f5<br>Corners(W): c1<br>mcts_0.025(B): a4<br>Corners(W): a3<br>mcts_0.025(B): c5<br>Corners(W): a5<br>mcts_0.025(B): b1<br>Corners(W): b4<br>mcts_0.025(B): c6<br>Corners(W): f7<br>mcts_0.025(B): f6<br>Corners(W): c7<br>mcts_0.025(B): f8<br>Corners(W): g8<br>mcts_0.025(B): h8<br>Corners(W): e3<br>mcts_0.025(B): c8<br>Corners(W): b8<br>mcts_0.025(B): f3<br>Corners(W): d8<br>mcts_0.025(B): e7<br>Corners(W): g3<br>mcts_0.025(B): g7<br>Corners(W): e8<br>mcts_0.025(B): g5<br>Corners(W): h4<br>mcts_0.025(B): d7<br>Corners(W): h7<br>mcts_0.025(B): h3<br>Corners(W): h2<br>mcts_0.025(B): g6<br>Corners(W): h5<br>mcts_0.025(B): a8<br>Corners(W): b6<br>mcts_0.025(B): b7<br>Corners(W): a7<br>mcts_0.025(B): a6<br>Corners(W): f2<br>mcts_0.025(B): h6<br>Corners(W): g4<br>mcts_0.025(B): a1<br>Corners(W): b2<br>mcts_0.025(B): g1<br>Corners(W): b5<br>mcts_0.025(B): h1<br>Corners(W): g2<br>Game over: Final score 37-27<br>Black wins!</div>

            <div class="leaderboard-container">
                <h3>Strategy Leaderboard</h3>
                <div>
                    <button id="run-tournament-btn" class="tournament-btn">Run Tournament</button>
                    <button id="reset-tournament-btn" class="tournament-btn">Reset Records</button>
                </div>
                <div id="tournament-status">Tournament results will appear here.</div>
                <table id="leaderboard-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Strategy</th>
                            <th>Win Rate</th>
                            <th>W</th>
                            <th>L</th>
                            <th>D</th>
                            <th>G</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboard-body"><tr><td>1</td><td>mcts_0.025</td><td>90.0%</td><td>9</td><td>1</td><td>0</td><td>10</td></tr><tr><td>2</td><td>mcts_0.05</td><td>90.0%</td><td>9</td><td>1</td><td>0</td><td>10</td></tr><tr><td>3</td><td>Random</td><td>40.0%</td><td>4</td><td>6</td><td>0</td><td>10</td></tr><tr><td>4</td><td>Corners</td><td>30.0%</td><td>3</td><td>7</td><td>0</td><td>10</td></tr><tr><td>5</td><td>Positional</td><td>30.0%</td><td>3</td><td>7</td><td>0</td><td>10</td></tr><tr><td>6</td><td>Greedy</td><td>20.0%</td><td>2</td><td>8</td><td>0</td><td>10</td></tr></tbody>
                </table>
            </div>
        </div>

        <div class="code-container">
            <h3>Custom JavaScript Strategy</h3>
            <div><label for="strategy-name">Strategy Name:</label><input type="text" id="strategy-name" value="myOthelloStrategy"></div>
            <textarea class="code-editor" id="js-code">// Default Positional Strategy Code...\nconst validMoves = getValidMoves(player); if (validMoves.length === 0) return null; const positionWeights = [[120,-20,20,5,5,20,-20,120],[-20,-40,-5,-5,-5,-5,-40,-20],[20,-5,15,3,3,15,-5,20],[5,-5,3,3,3,3,-5,5],[5,-5,3,3,3,3,-5,5],[20,-5,15,3,3,15,-5,20],[-20,-40,-5,-5,-5,-5,-40,-20],[120,-20,20,5,5,20,-20,120]]; let bestMove = null; let bestScore = -Infinity; for (const move of validMoves) { const score = positionWeights[move.row][move.col]; if (score &gt; bestScore) { bestScore = score; bestMove = move; } } return bestMove;</textarea>
            <div class="strategy-buttons"><button id="save-strategy">Save Strategy</button><button id="clear-editor">Clear Editor</button></div>
            <div class="strategy-upload">
                <h4>Upload Strategy Files (.js)</h4><input type="file" id="strategy-file-input" accept=".js" multiple=""><button id="upload-strategies">Upload Strategies</button>
                <div class="upload-status" id="upload-status-msg" style="display:none;"></div>
            </div>
            <div class="intelligent-system-upload">
                <h4>Upload Intelligent System (with Interaction)</h4>
                <p>Your system will have maximum 60 seconds to analyze the stage and generate a tailored strategy. </p>
                <input type="file" id="intelligent-system-file-input" accept=".js">
                <button id="upload-intelligent-system">Upload Intelligent System</button>
                <div class="intelligent-system-progress" id="intelligent-system-progress">
                    <div class="intelligent-system-progress-bar" id="intelligent-system-progress-bar"></div>
                </div>
                <div class="intelligent-system-status" id="intelligent-system-status"></div>
            </div><br>
            <h4>Saved Strategies</h4>
            <div class="saved-strategies" id="strategy-list"><div class="strategy-item"><span>mcts_0.025</span><div class="buttons"><button>Edit</button><button class="delete-btn">Delete</button></div></div><div class="strategy-item"><span>mcts_0.05</span><div class="buttons"><button>Edit</button><button class="delete-btn">Delete</button></div></div></div>
            <!-- <div class="template-container">
                <h4>Strategy Template Info</h4>
                <p>Function must be callable like `myStrategy(board, player, getValidMoves, makeMove)`. Return `{row,
                    col}` or `null`.</p>
            </div> -->
        </div>
    </div>

    <script>
        // --- Constants and Globals ---
        const EMPTY = 0; const BLACK = 1; const WHITE = 2; const BLOCKED = 3;
        const MAX_AI_TIME_PER_GAME = 20000; // Maximum time to spend in each game (5 seconds)
        let blackTimeUsed = 0; // total time used - black (ms)
        let whiteTimeUsed = 0; // total time used - white (ms)
        let BOARD_SIZE = 8;
        let board = []; let currentPlayer = BLACK; let gameRunning = false;
        let moveLog = []; let savedStrategies = {}; let compiledStudentAIs = {};
        // Intelligent System globals
        let intelligentSystems = {}; // Store uploaded intelligent systems
        let compiledIntelligentSystems = {}; // Cached compiled versions
        let isIntelligentSystemAnalyzing = false; // Flag for analysis state
        let currentAnalysisStage = null; // Current stage being analyzed
        let gameStartLogged = false; let currentStage = null;
        let currentTournamentStageConfig = null;
        let leaderboardData = { matches: [], results: {} };
        let aiThinking = false;
        let gameLoopTimeout = null; // Declare timeout handle globally
        let isTournamentMode = false;

        // --- DOM Elements ---
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const blackScoreElement = document.getElementById('black-score');
        const whiteScoreElement = document.getElementById('white-score');
        const blackTimerElement = document.getElementById('black-timer');
        const whiteTimerElement = document.getElementById('white-timer');
        const stageSelect = document.getElementById('stageSelect');
        const blackAISelect = document.getElementById('black-ai');
        const whiteAISelect = document.getElementById('white-ai');
        const startButton = document.getElementById('start-btn');
        const resetButton = document.getElementById('reset-btn');
        const gameLogElement = document.getElementById('game-log');
        const jsCodeElement = document.getElementById('js-code');
        const strategyNameInput = document.getElementById('strategy-name');
        const saveStrategyButton = document.getElementById('save-strategy');
        const clearEditorButton = document.getElementById('clear-editor');
        const strategyListElement = document.getElementById('strategy-list');
        const strategyFileInput = document.getElementById('strategy-file-input');
        const uploadStrategiesButton = document.getElementById('upload-strategies');
        const uploadStatusMsg = document.getElementById('upload-status-msg');
        const runTournamentButton = document.getElementById('run-tournament-btn');
        const tournamentStatusElement = document.getElementById('tournament-status');
        const leaderboardBody = document.getElementById('leaderboard-body');
        // New Intelligent System Elements
        const intelligentSystemFileInput = document.getElementById('intelligent-system-file-input');
        const uploadIntelligentSystemButton = document.getElementById('upload-intelligent-system');
        const intelligentSystemProgress = document.getElementById('intelligent-system-progress');
        const intelligentSystemProgressBar = document.getElementById('intelligent-system-progress-bar');
        const intelligentSystemStatus = document.getElementById('intelligent-system-status');


        // --- Stage Definitions ---
        stages = [
            {
                name: "Standard 8x8",
                boardSize: 8,
                initialBlocked: [],
                initialPlayer1: [{ r: 3, c: 4 }, { r: 4, c: 3 }],
                initialPlayer2: [{ r: 3, c: 3 }, { r: 4, c: 4 }]
            },
            {
                name: "Small Board (6x6)",
                boardSize: 6,
                initialBlocked: [],
                initialPlayer1: [{ r: 2, c: 3 }, { r: 3, c: 2 }],
                initialPlayer2: [{ r: 2, c: 2 }, { r: 3, c: 3 }]
            },
            {
                name: "8x8 (Partial C-Squares-cw)",
                boardSize: 8,
                initialBlocked: [{ r: 0, c: 1 }, { r: 1, c: 7 }, { r: 7, c: 6 }, { r: 6, c: 0 }],
                initialPlayer1: [{ r: 3, c: 4 }, { r: 4, c: 3 }],
                initialPlayer2: [{ r: 3, c: 3 }, { r: 4, c: 4 }]
            },
            // ================
            {
                name: "8x8 (No X-Squares)",
                boardSize: 8,
                initialBlocked: [{ r: 1, c: 1 }, { r: 1, c: 6 }, { r: 6, c: 1 }, { r: 6, c: 6 }],
                initialPlayer1: [{ r: 3, c: 4 }, { r: 4, c: 3 }],
                initialPlayer2: [{ r: 3, c: 3 }, { r: 4, c: 4 }]
            },
            {
                name: "8x8 (No Sweet)",
                boardSize: 8,
                initialBlocked: [{ r: 2, c: 2 }, { r: 5, c: 5 }, { r: 5, c: 2 }, { r: 2, c: 5 }],
                initialPlayer1: [{ r: 3, c: 4 }, { r: 4, c: 3 }],
                initialPlayer2: [{ r: 3, c: 3 }, { r: 4, c: 4 }]
            },
            {
                name: "8x8 (First Move Restriction)",
                boardSize: 8,
                initialBlocked: [{ r: 2, c: 3 }, { r: 5, c: 4 }, { r: 4, c: 2 }, { r: 3, c: 5 }],
                initialPlayer1: [{ r: 3, c: 4 }, { r: 4, c: 3 }],
                initialPlayer2: [{ r: 3, c: 3 }, { r: 4, c: 4 }]
            },
            {
                name: "10x10 (Corner Missing)",
                boardSize: 10,
                initialBlocked: [{ r: 0, c: 4 }, { r: 0, c: 5 }, { r: 1, c: 4 }, { r: 1, c: 5 },
                { r: 8, c: 4 }, { r: 8, c: 5 }, { r: 9, c: 4 }, { r: 9, c: 5 },
                { r: 4, c: 0 }, { r: 5, c: 0 }, { r: 4, c: 1 }, { r: 5, c: 1 },
                { r: 4, c: 8 }, { r: 5, c: 8 }, { r: 4, c: 9 }, { r: 5, c: 9 }],
                initialPlayer1: [{ r: 4, c: 5 }, { r: 5, c: 4 }],
                initialPlayer2: [{ r: 4, c: 4 }, { r: 5, c: 5 }]
            },
            // ================
        ];
        // --- Built-in Strategies ---
        const builtInStrategies = { /* ... Same ... */
            random: function (p) { const m = getValidMoves(p); if (m.length === 0) return null; return m[Math.floor(Math.random() * m.length)]; },
            greedy: function (currentBoard, player, validMoves, makeMoveFunc) {
                // Return null if no valid moves
                if (validMoves.length === 0) {
                    return null;
                }

                let bestMove = null;  // Variable to store the best move
                let maxFlips = -1;  // Maximum number of flips (starts at -1 to allow selecting moves that flip 0 pieces)

                // Iterate through all valid moves
                for (const move of validMoves) {
                    // --- ★★★ Start calculating currentFlips logic ★★★ ---
                    const tempBoard = currentBoard.map(row => [...row]); // Copy the board for simulation
                    const opponent = player === BLACK ? WHITE : BLACK;
                    let currentFlips = 0; // Number of pieces flipped by the current move (declared here!)

                    // Simulate the current move on the copied board
                    tempBoard[move.row][move.col] = player;

                    // Search 8 directions and count flipped pieces
                    const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                    for (const [dr, dc] of directions) {
                        let r = move.row + dr;
                        let c = move.col + dc;
                        const piecesToFlip = []; // Candidates for flipping

                        while (isWithinBoard(r, c) && tempBoard[r][c] === opponent) {
                            piecesToFlip.push([r, c]);
                            r += dr;
                            c += dc;
                        }

                        if (piecesToFlip.length > 0 && isWithinBoard(r, c) && tempBoard[r][c] === player) {
                            currentFlips += piecesToFlip.length; // Accumulate the number of flipped pieces
                        }
                    }
                    // --- ★★★ End of currentFlips calculation logic ★★★ ---

                    // Update if current move flips more pieces than the current max
                    if (currentFlips > maxFlips) {
                        maxFlips = currentFlips;
                        bestMove = move;
                    }
                }

                // Fallback logic (select random move if bestMove is still null)
                if (bestMove === null && validMoves.length > 0) {
                    console.warn("Greedy AI fallback: No move increased flips > -1, selecting random valid move.");
                    bestMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                }

                // Return the final selected move
                return bestMove;
            },

            corners: function (currentBoard, player, validMoves, makeMoveFunc) {

                if (validMoves.length === 0) {
                    return null;
                }
                // Find corners (using the passed validMoves)
                const corners = validMoves.filter(mv => (mv.row === 0 || mv.row === BOARD_SIZE - 1) && (mv.col === 0 || mv.col === BOARD_SIZE - 1));
                if (corners.length > 0) {
                    return corners[0];
                }
                // Find edges (using the passed validMoves)
                const edges = validMoves.filter(mv => mv.row === 0 || mv.row === BOARD_SIZE - 1 || mv.col === 0 || mv.col === BOARD_SIZE - 1);
                if (edges.length > 0) {
                    // Return a random edge (optional, otherwise return the first one)
                    return edges[Math.floor(Math.random() * edges.length)];
                }
                // Call greedy if no corners/edges (modified greedy call to use passed validMoves)
                return builtInStrategies.greedy(currentBoard, player, validMoves, makeMoveFunc);
            },

            positional: function (currentBoard, player, validMoves, makeMoveFunc) {
                if (validMoves.length === 0) {
                    return null;
                }

                let bestM = null;
                let bestS = -Infinity;

                if (BOARD_SIZE !== 8) {
                    console.warn("Positional weights only valid for 8x8! Falling back to greedy.");

                    return builtInStrategies.greedy(currentBoard, player, validMoves, makeMoveFunc);
                }


                const w8 = [[120, -20, 20, 5, 5, 20, -20, 120], [-20, -40, -5, -5, -5, -5, -40, -20], [20, -5, 15, 3, 3, 15, -5, 20], [5, -5, 3, 3, 3, 3, -5, 5], [5, -5, 3, 3, 3, 3, -5, 5], [20, -5, 15, 3, 3, 15, -5, 20], [-20, -40, -5, -5, -5, -5, -40, -20], [120, -20, 20, 5, 5, 20, -20, 120]]; // 8x8 weights
                for (const mv of validMoves) {
                    const s = w8[mv.row][mv.col];
                    if (s > bestS) {
                        bestS = s;
                        bestM = mv;
                    }
                }
                return bestM;
            }
        };

        // --- Game Logic ---
        function initializeBoard(stageConfig, isPreview = false) {
            console.log(`Init board. Stage:${stageConfig ? stageConfig.name : 'Default'}, Preview:${isPreview}`);
            currentStage = stageConfig;
            BOARD_SIZE = stageConfig ? stageConfig.boardSize : 8;
            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));

            // Apply stage configuration (blocked cells, initial pieces)
            if (stageConfig) {
                (stageConfig.initialBlocked || []).forEach(p => {
                    if (isWithinBoard(p.r, p.c)) board[p.r][p.c] = BLOCKED;
                });
                (stageConfig.initialPlayer1 || []).forEach(p => {
                    if (isWithinBoard(p.r, p.c) && board[p.r][p.c] === EMPTY) board[p.r][p.c] = BLACK;
                });
                (stageConfig.initialPlayer2 || []).forEach(p => {
                    if (isWithinBoard(p.r, p.c) && board[p.r][p.c] === EMPTY) board[p.r][p.c] = WHITE;
                });
            } else { // Default setup if no stageConfig (e.g., fallback)
                if (BOARD_SIZE === 8) {
                    const mid = Math.floor(BOARD_SIZE / 2);
                    board[mid - 1][mid - 1] = WHITE;
                    board[mid - 1][mid] = BLACK;
                    board[mid][mid - 1] = BLACK;
                    board[mid][mid] = WHITE;
                } else {
                    console.warn("No default setup for non-8x8 board without stage config");
                }
            }

            // --- Prepare board element ---
            boardElement.innerHTML = '';
            const cs = 50; // cell size
            boardElement.style.gridTemplateColumns = `repeat(${BOARD_SIZE}, ${cs}px)`;
            boardElement.style.gridTemplateRows = `repeat(${BOARD_SIZE}, ${cs}px)`;
            // Calculate board dimensions including gaps and padding (adjust calculation if needed)
            const bDim = BOARD_SIZE * cs + (BOARD_SIZE - 1) * 1 + 8; // Assuming 1px gap, 4px padding on each side
            boardElement.style.width = `${bDim}px`;
            boardElement.style.height = `${bDim}px`;

            // Create cells
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.style.width = `${cs}px`;
                    cell.style.height = `${cs}px`;
                    boardElement.appendChild(cell);
                }
            }

            // --- Update display and score (common for preview and game start) ---
            updateBoardDisplay(); // Render initial pieces/blocked cells
            const scores = countDiscs();
            blackScoreElement.textContent = scores.black;
            whiteScoreElement.textContent = scores.white;

            // --- Specific actions based on mode (Preview vs Actual Game Start) ---
            if (!isPreview) {
                // This block runs when starting the actual game (called from startGame)
                currentPlayer = BLACK;
                // selectedCell = null; // Assuming selectedCell exists globally or resetting it here
                gameOver = false; // *** Set game over to false for game start ***
                console.log(`[initializeBoard] gameOver set to false. Current value: ${gameOver}`); // <<< 추가 로그 1
                aiThinking = false;
                gameRunning = false; // Ensure gameRunning starts false, startGame will set it true
                // Additional game start resets if needed
                // moveLog = []; // Resetting move log might happen in startGame instead
                // updatePlayerIDs(); // Should be called after player controllers are set
                updateGameLog(); // Clear or update log display
                // messageElement.textContent = ...; // Status message set in startGame
                statusElement.textContent = `Game ready to start. ${getPlayerName(currentPlayer)} turn.`;
                statusElement.className = 'status'; // Reset status class
                console.log(`[initializeBoard] End of !isPreview block. gameOver value: ${gameOver}`); // <<< 추가 로그 2

            } else {
                // This block runs for preview only (called on page load or stage change)
                statusElement.textContent = "Stage selected. Click Start Game button.";
                statusElement.style.backgroundColor = '#4CAF50';
                startButton.disabled = false; // Ensure start button is enabled for preview
                gameOver = true; // *** Set game over to true for preview mode ***
            }
            // Note: updateStatus() might be called in startGame or switchTurn, not necessarily needed here.
        }


        function createInitialBoard(stageConfig) {
            if (!stageConfig) {
                stageConfig = stages[0];
            }
            const boardSize = stageConfig.boardSize || 8;
            const board = Array(boardSize).fill().map(() => Array(boardSize).fill(EMPTY));

            if (stageConfig) {
                (stageConfig.initialBlocked || []).forEach(p => {
                    if (isWithinBoard(p.r, p.c)) board[p.r][p.c] = BLOCKED;
                });
                (stageConfig.initialPlayer1 || []).forEach(p => {
                    if (isWithinBoard(p.r, p.c) && board[p.r][p.c] === EMPTY) board[p.r][p.c] = BLACK;
                });
                (stageConfig.initialPlayer2 || []).forEach(p => {
                    if (isWithinBoard(p.r, p.c) && board[p.r][p.c] === EMPTY) board[p.r][p.c] = WHITE;
                });
            } else {
                const mid = Math.floor(boardSize / 2);
                board[mid - 1][mid - 1] = WHITE;
                board[mid - 1][mid] = BLACK;
                board[mid][mid - 1] = BLACK;
                board[mid][mid] = WHITE;
            }
            return board;
        }


        function updateBoardDisplay() { /* ... Same (renders board state, including blocked) ... */ const cells = boardElement.querySelectorAll('.cell'); cells.forEach(cell => { const r = parseInt(cell.dataset.row); const c = parseInt(cell.dataset.col); cell.innerHTML = ''; cell.classList.remove('blocked', 'black', 'white', 'valid-move-hint', 'playable'); cell.onclick = null; if (!isWithinBoard(r, c)) return; const cellState = board[r][c]; if (cellState === BLACK) { const d = document.createElement('div'); d.className = 'disc black'; cell.appendChild(d); cell.style.cursor = 'default'; } else if (cellState === WHITE) { const d = document.createElement('div'); d.className = 'disc white'; cell.appendChild(d); cell.style.cursor = 'default'; } else if (cellState === BLOCKED) { cell.classList.add('blocked'); cell.style.cursor = 'not-allowed'; } else {/*EMPTY*/const isHumanTurn = (currentPlayer === BLACK && blackAISelect.value === 'human') || (currentPlayer === WHITE && whiteAISelect.value === 'human'); if (gameRunning && !aiThinking && isHumanTurn && isValidMove(r, c, currentPlayer)) { cell.classList.add('valid-move-hint'); cell.classList.add('playable');/* Listener added globally */ } else { cell.style.cursor = 'default'; } } }); const s = countDiscs(); blackScoreElement.textContent = s.black; whiteScoreElement.textContent = s.white; }
        function countDiscs() { /* ... Same ... */ let b = 0, w = 0; for (let r = 0; r < BOARD_SIZE; r++)for (let c = 0; c < BOARD_SIZE; c++) { if (board[r][c] === BLACK) b++; else if (board[r][c] === WHITE) w++; } return { black: b, white: w }; }
        function isWithinBoard(r, c) { return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE; }

        function isValidMove(row, col, player, currentBoard = board) {
            // Check if the move is within the board and the cell is empty
            if (!isWithinBoard(row, col) || currentBoard[row][col] !== EMPTY) {
                return false;
            }

            const opponent = player === BLACK ? WHITE : BLACK;
            const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];

            // Get current stage configuration for the special rule check
            const stageConfig = currentStage || stages[0];
            const ignoreOcclusion = stageConfig.ignoreOcclusion || false;

            // For each direction from the placed piece
            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                let foundOpponent = false;
                let foundBlocked = false;

                // Search for opponent's pieces
                while (isWithinBoard(r, c)) {
                    if (currentBoard[r][c] === opponent) {
                        foundOpponent = true;
                    }
                    else if (currentBoard[r][c] === BLOCKED) {
                        foundBlocked = true;
                        // In normal rules, a blocked cell ends the search.
                        // With ignoreOcclusion=true, we continue through blocked cells
                        if (!ignoreOcclusion) {
                            break;
                        }
                    }
                    else if (currentBoard[r][c] === EMPTY) {
                        // An empty cell always ends the search
                        break;
                    }
                    else if (currentBoard[r][c] === player) {
                        // Found current player's piece, which could complete a valid move
                        // Valid if we found at least one opponent's piece and:
                        // - either no blocked cells
                        // - or ignoreOcclusion is true (blocked cells can be jumped over)
                        if (foundOpponent && (!foundBlocked || ignoreOcclusion)) {
                            return true;
                        }
                        break;
                    }

                    // Continue in the same direction
                    r += dr;
                    c += dc;
                }
            }

            // No valid move found in any direction
            return false;
        }

        // function isValidMove(row, col, player, currentBoard = board) {
        //     const targetBoard = currentBoard;
        //     if (!isWithinBoard(row, col) || targetBoard[row][col] !== EMPTY) {
        //         return false;
        //     }
        //     const opponent = player === BLACK ? WHITE : BLACK;
        //     const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
        //     for (const [dr, dc] of directions) {
        //         let r = row + dr;
        //         let c = col + dc;
        //         let foundOpponent = false;

        //         while (isWithinBoard(r, c) && targetBoard[r][c] === opponent) {
        //             foundOpponent = true;
        //             r += dr;
        //             c += dc;
        //         }

        //         if (foundOpponent && isWithinBoard(r, c) && targetBoard[r][c] === player) {
        //             return true;
        //         }
        //     }
        //     return false;
        // }

        function getValidMoves(player, currentBoard = board) {
            const moves = [];
            // Ensure we're using the correct board size from the current board
            const size = currentBoard.length;

            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (isValidMove(r, c, player, currentBoard)) {
                        moves.push({ row: r, col: c });
                    }
                }
            }

            // Add debug log to see all valid moves
            console.log(`Valid moves for player ${player}:`, moves);

            return moves;
        }

        // function makeMove(row, col, player) { /* ... Same (uses logMove) ... */ if (!isWithinBoard(row, col) || board[row][col] !== EMPTY) return; board[row][col] = player; logMove(row, col, player); const opp = player === BLACK ? WHITE : BLACK; const dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]; let flipped = false; for (const [dr, dc] of dirs) { let r = row + dr; let c = col + dc; const toFlip = []; while (isWithinBoard(r, c) && board[r][c] === opp) { toFlip.push([r, c]); r += dr; c += dc; } if (toFlip.length > 0 && isWithinBoard(r, c) && board[r][c] === player) { flipped = true; for (const [fr, fc] of toFlip) { board[fr][fc] = player; } } } updateBoardDisplay(); return flipped; }
        function makeMove(row, col, player) {
            if (!isWithinBoard(row, col) || board[row][col] !== EMPTY) return false;

            board[row][col] = player;

            // 기존 로그 함수 호출 유지
            logMove(row, col, player);

            const opponent = player === BLACK ? WHITE : BLACK;
            const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];

            // Get current stage configuration for the special rule check
            const stageConfig = currentStage || stages[0];
            const ignoreOcclusion = stageConfig.ignoreOcclusion || false;

            // 뒤집힌 말의 총 개수를 추적
            const capturedPieces = [];
            let flipped = false;

            for (const [dr, dc] of directions) {
                let r = row + dr;
                let c = col + dc;
                const toFlip = [];
                let foundBlocked = false;
                let foundOpponent = false;

                // Collect pieces to flip, considering blocked cells
                while (isWithinBoard(r, c)) {
                    if (board[r][c] === opponent) {
                        toFlip.push([r, c]);
                        foundOpponent = true;
                    }
                    else if (board[r][c] === BLOCKED) {
                        foundBlocked = true;
                        // In normal rules, a blocked cell ends the search
                        if (!ignoreOcclusion) {
                            break;
                        }
                        // We continue past the blocked cell but don't add it to toFlip
                    }
                    else if (board[r][c] === EMPTY) {
                        // Empty cell always stops the search
                        break;
                    }
                    else if (board[r][c] === player) {
                        // Found the player's piece, check if we can flip
                        if (foundOpponent && toFlip.length > 0 && (!foundBlocked || ignoreOcclusion)) {
                            flipped = true;
                            // Flip all collected pieces
                            for (const [fr, fc] of toFlip) {
                                board[fr][fc] = player;
                                capturedPieces.push([fr, fc]); // 뒤집힌 말 기록
                            }
                        }
                        break;
                    }

                    r += dr;
                    c += dc;
                }
            }

            // Save game state to gameLogger if it's initialized
            if (window.gameLogger) {
                window.gameLogger.logMove(
                    player,
                    { row: row, col: col },      // Position as an object
                    Array.from(board, row => [...row]), // Deep copy of board state
                    capturedPieces.length        // Number of captured pieces
                );
            }

            updateBoardDisplay();
            return flipped;
        }

        function handleHumanMove(event) {
            // Check if it's a human's turn
            const isHumanTurn = (currentPlayer === BLACK && blackAISelect.value === 'human') ||
                (currentPlayer === WHITE && whiteAISelect.value === 'human');

            // Only proceed if it's a human turn and game is running
            if (isHumanTurn && gameRunning && !aiThinking && !gameOver) {
                // Check if human has any valid moves
                const validMoves = getValidMoves(currentPlayer);

                // If human has no valid moves, handle passing automatically
                if (validMoves.length === 0) {
                    console.log(`Human player ${currentPlayer} has no valid moves. Passing automatically.`);
                    logPass(currentPlayer);

                    // Determine next player
                    const opponent = currentPlayer === BLACK ? WHITE : BLACK;

                    // Check if game should end (both players have no moves)
                    const opponentMoves = getValidMoves(opponent, board);
                    if (opponentMoves.length === 0) {
                        console.log("Both players have no moves. Ending game.");
                        endGame();
                        return;
                    }

                    // Pass to opponent (don't use determineNextPlayer here since we're forcing a pass)
                    currentPlayer = opponent;
                    updateStatus();

                    // Trigger opponent's turn (AI)
                    makeAIMove(false);
                    return;
                }
            }

            // Original click handling logic - only process if clicked on a cell
            const cell = event.target.closest('.cell');
            if (!cell || !gameRunning || aiThinking || gameOver) return;

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            // Check if it's currently a human's turn
            if (!isHumanTurn) return;

            if (isValidMove(row, col, currentPlayer)) {
                console.log(`Human Move: P${currentPlayer} plays at R${row} C${col}`);
                makeMove(row, col, currentPlayer); // Execute the move (logs internally)

                // Store current player before determining next player
                const previousPlayer = currentPlayer;

                // Determine next player based on the "fewer pieces" rule
                currentPlayer = determineNextPlayer();
                updateStatus(); // Update status for the new player

                // Check if it's the same player's turn again (fewer pieces rule)
                if (previousPlayer === currentPlayer) {
                    console.log(`Player ${currentPlayer} continues (fewer pieces rule)`);
                    logMessage(`${getPlayerName(currentPlayer)} continues (fewer pieces rule)`);

                    // Check if the continuing player has valid moves
                    const nextMoves = getValidMoves(currentPlayer);
                    if (nextMoves.length === 0) {
                        console.log(`Continuing player ${currentPlayer} has no valid moves. Passing.`);
                        logPass(currentPlayer);

                        // Force switch to other player
                        const otherPlayer = currentPlayer === BLACK ? WHITE : BLACK;
                        currentPlayer = otherPlayer;
                        updateStatus();
                    }
                }

                // Check for game over
                const blackMoves = getValidMoves(BLACK);
                const whiteMoves = getValidMoves(WHITE);

                if (blackMoves.length === 0 && whiteMoves.length === 0) {
                    console.log("Game end detected after human move - no valid moves for either player.");
                    endGame();
                } else {
                    // Continue game if there are still valid moves
                    console.log("Human move done, triggering next player check");
                    makeAIMove(false);
                }
            } else {
                console.log(`Human invalid move attempt at R${row} C${col}`);
                displayMessage("Invalid move!", 'error'); // Use helper
                setTimeout(() => updateStatus(), 1500); // Clear message after delay
            }
        }

        /**
         * Handles the logic for an AI player's turn.
         * Determines the AI type, gets a move from the strategy, validates it,
         * executes the move (or a fallback random move), and schedules the next turn.
         * Includes error handling to ensure the game continues even when an AI strategy fails.
         */
        async function makeAIMove(isTournament = false) {
            // --- 1. Initial Checks & Human Turn Handling ---
            console.log(`[makeAIMove] Enter. Player: ${currentPlayer}, Running: ${gameRunning}, Thinking: ${aiThinking}`);
            if (!gameRunning || gameOver) {
                console.log("[makeAIMove] Aborting: Game not running or over.");
                aiThinking = false; // Ensure flag is reset
                if (gameLoopTimeout) clearTimeout(gameLoopTimeout); gameLoopTimeout = null;
                return;
            }

            const controllerId = currentPlayer === BLACK ? blackAISelect.value : whiteAISelect.value;

            // For human player, we don't track time
            if (controllerId === 'human') {
                aiThinking = false; // Not AI's turn to think
                updateStatus();      // Update status to show it's human's turn
                updateBoardDisplay(); // Update visual hints for human
                console.log(`[makeAIMove] Human turn P${currentPlayer}. Waiting for input.`);
                return; // Exit AI logic, wait for human click
            }

            // --- 2. AI Turn Setup ---
            if (aiThinking) { // Prevent duplicate AI thinking processes
                console.warn(`[makeAIMove] AI P${currentPlayer} is already thinking. Aborting duplicate call.`);
                return;
            }
            aiThinking = true;
            const aiIdentifier = getPlayerName(currentPlayer); // Get AI name (e.g., "Greedy", "myStrategy")
            displayMessage(`${aiIdentifier} (AI) is thinking...`, 'thinking');
            // Optional: updateBoardDisplay() here if you want to remove hints during AI thinking

            const strategyFn = getCompiledStrategy(controllerId, currentPlayer); // Get the actual AI function
            if (!strategyFn) {
                console.error(`[makeAIMove] Strategy function failed for ${controllerId}`);
                logMessage(`Error: AI ${aiIdentifier} failed. Using random move.`);
                // Instead of ending the game, use a random move fallback when strategy compilation fails
                useFallbackMove(currentPlayer, isTournament);
                return;
            }

            // --- 3. Calculate Valid Moves (Once) ---
            // Ensure getValidMoves uses the current global board state here
            const validMoves = getValidMoves(currentPlayer, board);
            console.log(`[makeAIMove] P${currentPlayer} has ${validMoves.length} valid moves.`);

            // --- 4. Handle No Valid Moves (Pass/End Game) ---
            if (validMoves.length === 0) {
                console.log(`[makeAIMove] P${currentPlayer} has no moves. Checking opponent...`);
                const opponent = currentPlayer === BLACK ? WHITE : BLACK;
                // Check opponent's moves based on the current board state
                if (getValidMoves(opponent, board).length === 0) {
                    console.log("[makeAIMove] Both players have no moves. Ending game.");
                    aiThinking = false;
                    endGame();
                    return;
                }
                // Current player passes, switch to opponent
                console.log(`[makeAIMove] P${currentPlayer} passes.`);
                logPass(currentPlayer);
                currentPlayer = opponent;
                updateStatus();
                aiThinking = false; // Reset thinking BEFORE scheduling next turn check
                makeAIMove(isTournament); // Schedule check for the opponent's turn
                return;
            }

            // --- 5. Schedule AI Execution (Allows UI Update) ---
            const moveDelay = isTournament ? 0 : 20; // Delay for AI move
            if (gameLoopTimeout) clearTimeout(gameLoopTimeout); // Clear any previous timeout

            gameLoopTimeout = setTimeout(async () => {
                // Re-check state inside timeout callback for safety
                if (!gameRunning || gameOver || !aiThinking) {
                    console.log(`[makeAIMove -> setTimeout] Aborting before AI execution. GameRunning: ${gameRunning}, GameOver: ${gameOver}, AIThinking: ${aiThinking}`);
                    aiThinking = false; return;
                }
                console.log(`[makeAIMove -> setTimeout] Executing AI logic for ${aiIdentifier} (P${currentPlayer})`);

                try {
                    // --- 6. Call AI Strategy Function with Time Tracking ---
                    console.log(`[makeAIMove -> setTimeout] Calling strategy function for ${aiIdentifier}...`);
                    const startTime = performance.now();

                    // Create a deep copy of the board to pass to the AI
                    const currentBoardState = board.map(r => [...r]);

                    // Pass the board state, player, the pre-calculated valid moves list, and makeMove simulator
                    const move = await strategyFn(currentBoardState, currentPlayer, validMoves, makeMove);

                    // Calculate time used for this move
                    const endTime = performance.now();
                    const moveTime = endTime - startTime;

                    // Accumulate time used based on current player
                    if (currentPlayer === BLACK) {
                        blackTimeUsed += moveTime;
                    } else {
                        whiteTimeUsed += moveTime;
                    }

                    // Update timers in UI
                    updateTimers();

                    console.log(`[makeAIMove -> setTimeout] ${aiIdentifier} returned move:`, move,
                        `in ${(moveTime / 1000).toFixed(3)}s (total: ${currentPlayer === BLACK ? blackTimeUsed.toFixed(0) : whiteTimeUsed.toFixed(0)}ms)`);

                    // Check if player exceeded time limit
                    if (checkTimeLimit(currentPlayer, currentPlayer === BLACK ? blackTimeUsed : whiteTimeUsed)) {
                        return; // Game ended due to time limit violation
                    }

                    // --- 7. Validate AI's Returned Move & Handle Fallback ---
                    let actualMove = move;
                    let isFallback = false;

                    // Check if move is null or if it's not actually in the list of valid moves calculated earlier
                    const isReturnedMoveInList = move && validMoves.some(v => v.row === move.row && v.col === move.col);

                    if (!move || !isReturnedMoveInList) {
                        // --- Detailed Logging for Debugging ---
                        console.log('--- Invalid Move Detected ---');
                        console.log('AI Identifier:', aiIdentifier);
                        console.log('Returned move:', move);
                        console.log('Current player:', currentPlayer);
                        console.log('Calculated validMoves:', validMoves); // Log the list AI should have chosen from
                        if (move) {
                            // Optionally re-check with isValidMove for more info, but the primary check is inclusion in validMoves
                            console.log('isValidMove result (for info):', isValidMove(move.row, move.col, currentPlayer, board));
                        }
                        console.log('Current board state:');
                        console.table(board);
                        // --- End Detailed Logging ---

                        // Fallback: Select a random move from the validMoves list
                        actualMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                        isFallback = true;

                        if (!actualMove) { // Should not happen if validMoves.length > 0
                            console.error("Fallback failed - Could not select random move from non-empty list?");
                            useFallbackMove(currentPlayer, isTournament);
                            return;
                        }
                        console.log(`[makeAIMove -> setTimeout] Fallback move selected:`, actualMove);
                    }

                    // --- 8. Execute the Chosen Move ---
                    console.log(`[makeAIMove -> setTimeout] Executing makeMove for P${currentPlayer}:`, actualMove);
                    makeMove(actualMove.row, actualMove.col, currentPlayer); // makeMove logs the move and updates display

                    // --- 9. Determine Next Player based on Rules ---
                    const previousPlayer = currentPlayer; // Store current player before switching
                    currentPlayer = determineNextPlayer();
                    updateStatus(); // Update status for the NEW current player
                    console.log(`[makeAIMove -> setTimeout] Switched player from P${previousPlayer} to P${currentPlayer}.`);

                    // Check if same player continues (for fewer pieces rule)
                    if (previousPlayer === currentPlayer) {
                        console.log(`[makeAIMove -> setTimeout] Same player (${getPlayerName(currentPlayer)}) continues (fewer pieces rule)`);
                        logMessage(`${getPlayerName(currentPlayer)} continues (fewer pieces rule)`);
                    }

                    aiThinking = false; // Reset thinking flag *** AFTER all synchronous work is done ***

                    // Schedule the check for the next turn
                    console.log(`[makeAIMove -> setTimeout] Scheduling check for next turn (P${currentPlayer}).`);
                    makeAIMove(isTournament); // Recursively call to check next player's turn type

                } catch (error) {
                    console.error(`[makeAIMove -> setTimeout] Error during AI logic or move execution (${aiIdentifier}):`, error);
                    logMessage(`Error in AI move (${aiIdentifier}): ${error.message}. Using random move.`);

                    // Add a small penalty time for error cases (100ms)
                    if (currentPlayer === BLACK) {
                        blackTimeUsed += 100;
                    } else {
                        whiteTimeUsed += 100;
                    }
                    updateTimers();

                    // Check time limit before using fallback
                    if (checkTimeLimit(currentPlayer, currentPlayer === BLACK ? blackTimeUsed : whiteTimeUsed)) {
                        return; // Game ended due to time limit violation
                    }

                    // Use fallback strategy when an error occurs
                    useFallbackMove(currentPlayer, isTournament);
                }
            }, moveDelay); // End of setTimeout callback
        }

        /**
         * Helper function to handle fallback move selection when an AI strategy fails.
         * This keeps the game running by making a random valid move instead of ending the game.
         */
        function useFallbackMove(player, isTournament) {
            // Get valid moves for current player
            const validMoves = getValidMoves(player, board);

            // If no valid moves, handle the pass scenario
            if (validMoves.length === 0) {
                const opponent = player === BLACK ? WHITE : BLACK;

                // Check if game should end (both players have no moves)
                if (getValidMoves(opponent, board).length === 0) {
                    aiThinking = false;
                    endGame();
                    return;
                }

                // Handle pass
                logPass(player);
                currentPlayer = opponent;
                updateStatus();
                aiThinking = false;
                makeAIMove(isTournament);
                return;
            }

            // Add a small time penalty for using the random fallback strategy
            const randomStrategyTime = 100; // 100ms penalty for using fallback

            if (player === BLACK) {
                blackTimeUsed += randomStrategyTime;
            } else {
                whiteTimeUsed += randomStrategyTime;
            }

            // Update timers display
            updateTimers();

            // Check if the player has exceeded time limit even with just the penalty
            if (checkTimeLimit(player, player === BLACK ? blackTimeUsed : whiteTimeUsed)) {
                return; // Game ended due to time limit violation
            }

            // Log that we're using random strategy
            logMessage(`${getPlayerName(player)} is using random strategy (fallback)`);

            // Select a random valid move
            const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
            console.log(`[useFallbackMove] Selected random move for P${player}:`, randomMove);

            // Execute the move
            makeMove(randomMove.row, randomMove.col, player);

            // Determine next player
            const previousPlayer = player;
            currentPlayer = determineNextPlayer();

            // Check if same player continues (for fewer pieces rule)
            if (previousPlayer === currentPlayer) {
                console.log(`[useFallbackMove] Same player (${getPlayerName(currentPlayer)}) continues (fewer pieces rule)`);
                logMessage(`${getPlayerName(currentPlayer)} continues (fewer pieces rule)`);
            }

            updateStatus();

            // Reset thinking flag
            aiThinking = false;

            // Schedule next turn
            makeAIMove(isTournament);
        }



        /**
         * Enhanced GameLogger class with improved logging functionality
         * Stores complete game information including player strategies and stage
         */
        class GameLogger {
            constructor() {
                this.moves = [];              // Current game moves
                this.boardStates = [];        // Current game board states
                this.currentPlayer = [];      // Current game player sequence
                this.capturedCounts = [];     // Number of pieces captured in each turn
                this.gameResults = [];        // Record of game results (for leaderboard)
                this.previousGames = [];      // Complete logs of previous games
            }

            /**
             * Records a move in the current game
             * @param {number} player - The player making the move (BLACK or WHITE)
             * @param {Object} position - Position {row, col} where the move was made
             * @param {Array} resultingBoard - The board state after the move
             * @param {number} capturedCount - Number of pieces captured by this move
             */
            logMove(player, position, resultingBoard, capturedCount = 0) {
                this.moves.push({ player, position });
                this.boardStates.push(JSON.parse(JSON.stringify(resultingBoard)));
                this.currentPlayer.push(player);
                this.capturedCounts.push(capturedCount);
            }

            getLogs() {
                if (this.moves && this.moves.length > 0) {
                    return {
                        moves: this.moves,
                        boards: this.boardStates,
                        players: this.currentPlayer,
                        capturedCounts: this.capturedCounts
                    };
                }

                if (this.previousGames && this.previousGames.length > 0) {
                    console.log("GameLogger.getLogs: Using data from the most recent previous game");
                    const lastGame = this.previousGames[this.previousGames.length - 1];

                    return {
                        moves: lastGame.moves || [],
                        boards: lastGame.boards || [],
                        players: lastGame.players || [],
                        capturedCounts: lastGame.capturedCounts || []
                    };
                }

                return {
                    moves: [],
                    boards: [],
                    players: [],
                    capturedCounts: []
                };
            }

            /**
             * Saves the completed game with all metadata and log
             * Called when a game ends to preserve the exact state and context
             * @param {number} blackScore - Final score for black player
             * @param {number} whiteScore - Final score for white player
             * @param {string} blackStrategy - Name of black player's strategy
             * @param {string} whiteStrategy - Name of white player's strategy
             * @param {Object} stageConfig - The stage configuration used for the game
             * @param {Array} moveLogArray - Array of text log messages
             * @return {Object} The saved game result object
             */
            saveGameWithLog(blackScore, whiteScore, blackStrategy, whiteStrategy, stageConfig, moveLogArray) {
                // Validate input parameters
                blackStrategy = blackStrategy || "Black";
                whiteStrategy = whiteStrategy || "White";
                const stageName = stageConfig && stageConfig.name ? stageConfig.name : "Unknown Stage";

                // Create complete log text from move log messages
                const gameLogText = moveLogArray.join('\n');

                // Store complete game data in previousGames
                this.previousGames.push({
                    moves: [...this.moves],
                    boards: [...this.boardStates],
                    players: [...this.currentPlayer],
                    capturedCounts: [...this.capturedCounts],
                    logText: gameLogText,  // Store the full text log
                    metadata: {
                        blackStrategy: blackStrategy,
                        whiteStrategy: whiteStrategy,
                        stage: stageName,
                        blackScore: blackScore,
                        whiteScore: whiteScore,
                        date: new Date().toISOString()
                    }
                });

                console.log(`Game saved with fixed log: ${blackStrategy}(B) vs ${whiteStrategy}(W) on ${stageName}`);

                // Also save to gameResults for leaderboard functionality
                const result = {
                    date: new Date().toISOString(),
                    blackScore,
                    whiteScore,
                    blackStrategy,
                    whiteStrategy,
                    stage: stageName,
                    winner: blackScore > whiteScore ? BLACK : (whiteScore > blackScore ? WHITE : 0),
                    totalMoves: this.moves.length
                };
                this.gameResults.push(result);

                // Reset current game data
                this.moves = [];
                this.boardStates = [];
                this.currentPlayer = [];
                this.capturedCounts = [];

                // Save to localStorage
                this.saveToLocalStorage();

                return result;
            }

            /**
             * Save game results to local storage
             * Only saves the 20 most recent results
             */
            saveToLocalStorage() {
                try {
                    const recentResults = this.gameResults.slice(-20);
                    localStorage.setItem('othelloGameResults', JSON.stringify(recentResults));
                } catch (e) {
                    console.error("Failed to save game results:", e);
                }
            }

            /**
             * Load game results from local storage
             */
            loadFromLocalStorage() {
                try {
                    const data = localStorage.getItem('othelloGameResults');
                    if (data) {
                        this.gameResults = JSON.parse(data);
                    }
                } catch (e) {
                    console.error("Failed to load game results:", e);
                }
            }

            /**
             * Get current game log data
             * @return {Object} Current game log data
             */
            getLogs() {
                return {
                    moves: this.moves,
                    boards: this.boardStates,
                    players: this.currentPlayer,
                    capturedCounts: this.capturedCounts
                };
            }

            reset() {
                this.moves = [];
                this.boardStates = [];
                this.currentPlayer = [];
                this.capturedCounts = [];

                console.log("GameLogger reset: Current game data cleared");
            }

            getBoardAtMove(moveIndex) {
                if (moveIndex >= 0 && moveIndex < this.boardStates.length) {
                    return this.boardStates[moveIndex];
                }
                return null;
            }

            getPlayerAtMove(moveIndex) {
                if (moveIndex >= 0 && moveIndex < this.currentPlayer.length) {
                    return this.currentPlayer[moveIndex];
                }
                return null;
            }
        }


        // IntelligentSystemInterface - Interface for interaction between AI systems and the Arena
        class IntelligentSystemInterface {
            constructor(gameLogger, boardController) {
                this.logger = gameLogger;
                this.boardController = boardController;
                this.isAnalyzing = false;
                this.analysisResults = {};
            }

            // Prepare game data to provide to the Intelligent System
            prepareGameData(stageConfig) {
                // Current stage information (WITHOUT special rule flags)
                const stageInfo = {
                    name: stageConfig.name,
                    boardSize: stageConfig.boardSize,
                    initialBlocked: stageConfig.initialBlocked || [],
                    initialPlayer1: stageConfig.initialPlayer1 || [],
                    initialPlayer2: stageConfig.initialPlayer2 || []
                    // fewerPiecesContinue and ignoreOcclusion flags removed
                };

                // Game log and result information
                const gameData = {
                    stage: stageInfo,
                    currentGameLog: this.logger.getLogs(),
                    // previousGames: this.logger.getPreviousGames(5), // Last 5 game logs
                    // gameResults: this.logger.getGameResults(null, 20) // Last 20 game results
                };

                return gameData;
            }

            // API that can be called from external Intelligent Systems
            getInteractionAPI(stageConfig) {
                const gameData = this.prepareGameData(stageConfig);

                // Define API object to expose to Intelligent Systems
                return {
                    // API to provide game data
                    getGameData: () => gameData,

                    // API to simulate the result of a move
                    simulateMove: (board, player, row, col) => {
                        // Move simulation logic
                        const boardCopy = board.map(r => [...r]);
                        const capturedPieces = this.simulateCapturedPieces(boardCopy, player, row, col);

                        if (capturedPieces.length > 0) {
                            boardCopy[row][col] = player;
                            capturedPieces.forEach(([r, c]) => {
                                boardCopy[r][c] = player;
                            });
                            return {
                                valid: true,
                                resultingBoard: boardCopy,
                                capturedCount: capturedPieces.length
                            };
                        }

                        return { valid: false };
                    },

                    // API to calculate valid moves
                    getValidMoves: (board, player) => {
                        return this.calculateValidMoves(board, player);
                    },

                    // API to evaluate a board position
                    evaluateBoard: (board, player) => {
                        return this.evaluateBoardPosition(board, player);
                    }
                };
            }

            // Helper function for move simulation
            simulateCapturedPieces(board, player, row, col) {
                if (board[row][col] !== EMPTY) return [];

                const boardSize = board.length;
                const opponent = player === BLACK ? WHITE : BLACK;
                const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                const capturedPieces = [];

                // Search in each direction
                for (const [dr, dc] of directions) {
                    let r = row + dr;
                    let c = col + dc;
                    const toFlip = [];

                    // Find opponent pieces
                    while (
                        r >= 0 && r < boardSize &&
                        c >= 0 && c < boardSize &&
                        board[r][c] === opponent
                    ) {
                        toFlip.push([r, c]);
                        r += dr;
                        c += dc;
                    }

                    // Flipping condition: opponent pieces surrounded by player's pieces
                    if (
                        toFlip.length > 0 &&
                        r >= 0 && r < boardSize &&
                        c >= 0 && c < boardSize &&
                        board[r][c] === player
                    ) {
                        capturedPieces.push(...toFlip);
                    }
                }

                return capturedPieces;
            }

            // Helper function to calculate valid moves
            calculateValidMoves(board, player) {
                const boardSize = board.length;
                const validMoves = [];

                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize; c++) {
                        if (board[r][c] !== EMPTY) continue;

                        const capturedPieces = this.simulateCapturedPieces(board, player, r, c);
                        if (capturedPieces.length > 0) {
                            validMoves.push({ row: r, col: c, capturedCount: capturedPieces.length });
                        }
                    }
                }

                return validMoves;
            }

            // Helper function to evaluate board position
            evaluateBoardPosition(board, player) {
                const boardSize = board.length;
                const opponent = player === BLACK ? WHITE : BLACK;

                let playerCount = 0;
                let opponentCount = 0;
                let mobilityScore = 0;
                let cornerScore = 0;
                let edgeScore = 0;

                // Calculate piece count and position scores
                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize; c++) {
                        if (board[r][c] === player) {
                            playerCount++;

                            // Corner score
                            if ((r === 0 || r === boardSize - 1) && (c === 0 || c === boardSize - 1)) {
                                cornerScore += 100;
                            }
                            // Edge score
                            else if (r === 0 || r === boardSize - 1 || c === 0 || c === boardSize - 1) {
                                edgeScore += 20;
                            }
                        }
                        else if (board[r][c] === opponent) {
                            opponentCount++;
                        }
                    }
                }

                // Calculate mobility score (number of valid moves)
                const playerMoves = this.calculateValidMoves(board, player).length;
                const opponentMoves = this.calculateValidMoves(board, opponent).length;
                mobilityScore = playerMoves - opponentMoves;

                // Overall evaluation
                return {
                    pieceScore: playerCount - opponentCount,
                    mobilityScore: mobilityScore,
                    cornerScore: cornerScore,
                    edgeScore: edgeScore,
                    totalScore: (playerCount - opponentCount) + mobilityScore * 2 + cornerScore + edgeScore * 0.5
                };
            }
        }


        // GameRollout class - Implements replay functionality for recorded games
        class GameRollout {
            constructor(gameBoard, gameLogger) {
                this.gameBoard = gameBoard;
                this.gameLogger = gameLogger;
                this.isRolling = false;
                this.currentMoveIndex = -1;
                this.rolloutSpeed = 2; // Default playback speed (ms)
                this.rolloutTimer = null;
                this.currentGameIndex = 0; // Track current game index
                this.gameStartIndices = [0]; // Store starting indices of each game
                this.movesPerGame = []; // Store move counts for each game
            }

            // Identify game boundaries based on board reset patterns
            analyzeGameBoundaries() {
                const logs = this.gameLogger.getLogs();

                if (!logs || !logs.boards || logs.boards.length === 0) {
                    this.gameStartIndices = [0];
                    this.movesPerGame = [];
                    return;
                }

                // Always start with first game at index 0
                this.gameStartIndices = [0];
                this.movesPerGame = [];

                // Initial board state of the first game
                const initialBoardState = logs.boards[0];

                // Look for board resets (return to initial state)
                for (let i = 1; i < logs.boards.length; i++) {
                    const currentBoard = logs.boards[i];

                    // Check if this board matches the initial state pattern
                    if (this.isBoardReset(currentBoard, initialBoardState)) {
                        this.gameStartIndices.push(i);

                        // Calculate moves for previous game
                        if (this.gameStartIndices.length > 1) {
                            const prevStart = this.gameStartIndices[this.gameStartIndices.length - 2];
                            this.movesPerGame.push(i - prevStart);
                        }
                    }
                }

                // Add the moves for the last game
                if (this.gameStartIndices.length > 0) {
                    const lastStart = this.gameStartIndices[this.gameStartIndices.length - 1];
                    this.movesPerGame.push(logs.boards.length - lastStart);
                } else {
                    this.movesPerGame.push(logs.boards.length);
                }

                console.log("Game boundaries identified by board resets:", this.gameStartIndices);
                console.log("Moves per game:", this.movesPerGame);
            }

            // Check if a board represents a reset to initial game state
            isBoardReset(board, initialBoard) {
                // Board size check
                if (board.length !== initialBoard.length) return false;

                // For Othello, compare the boards to see if they match the initial state
                let patternMatch = true;
                for (let r = 0; r < board.length; r++) {
                    for (let c = 0; c < board[r].length; c++) {
                        if (board[r][c] !== initialBoard[r][c]) {
                            patternMatch = false;
                            break;
                        }
                    }
                    if (!patternMatch) break;
                }

                // If exact match, it's definitely a reset
                if (patternMatch) return true;

                // As a backup, check for initial piece configuration
                // (2 black and 2 white pieces in center for standard Othello)
                let blackCount = 0;
                let whiteCount = 0;
                let emptyCount = 0;

                for (let r = 0; r < board.length; r++) {
                    for (let c = 0; c < board[r].length; c++) {
                        if (board[r][c] === 1) blackCount++;
                        else if (board[r][c] === 2) whiteCount++;
                        else if (board[r][c] === 0) emptyCount++;
                    }
                }

                // Initial state typically has 2 black and 2 white pieces
                // and most cells are empty
                const boardSize = board.length * board[0].length;
                const hasInitialPieceCount = (blackCount === 2 && whiteCount === 2);
                const mostlyEmpty = (emptyCount >= boardSize - 8); // Allow for some blocked cells

                return hasInitialPieceCount && mostlyEmpty;
            }

            // Calculate current turn number within the current game (starting from 1)
            getCurrentGameTurn() {
                if (this.currentMoveIndex < 0) return 0;

                // Find the starting index of the current game
                let gameStartIndex = 0;
                let gameIndex = 0;

                for (let i = this.gameStartIndices.length - 1; i >= 0; i--) {
                    if (this.gameStartIndices[i] <= this.currentMoveIndex) {
                        gameStartIndex = this.gameStartIndices[i];
                        gameIndex = i;
                        break;
                    }
                }

                this.currentGameIndex = gameIndex;
                // Calculate turn number within current game (1-based)
                return this.currentMoveIndex - gameStartIndex + 1;
            }

            // Get total number of turns in the current game
            getCurrentGameTotalTurns() {
                // Run analysis if not done yet
                if (this.gameStartIndices.length <= 1 && this.movesPerGame.length === 0) {
                    this.analyzeGameBoundaries();
                }

                const gameIndex = this.currentGameIndex;

                // Use pre-calculated turn counts if available
                if (gameIndex < this.movesPerGame.length) {
                    return this.movesPerGame[gameIndex];
                }

                // Calculate based on next game's starting point if turn counts not available
                const gameStartIndex = this.gameStartIndices[gameIndex];
                const nextGameIndex = gameIndex + 1 < this.gameStartIndices.length ?
                    this.gameStartIndices[gameIndex + 1] : this.gameLogger.getLogs().moves.length;

                return nextGameIndex - gameStartIndex;
            }

            // Get current simulation/game index
            getCurrentSimulationIndex() {
                return this.currentGameIndex;
            }


            // Start rollout playback
            start(startIndex = -1, endIndex = -1) {
                if (this.isRolling) {
                    this.stop();
                }

                // Get logs from gameLogger
                const logs = this.gameLogger.getLogs();

                // Check if current game logs are empty
                if (!logs || !logs.moves || logs.moves.length === 0) {
                    // Check if previous games data is available
                    if (this.gameLogger.previousGames && this.gameLogger.previousGames.length > 0) {
                        console.log("Using previousGames data for replay, game index:", this.currentGameIndex);
                        const selectedGame = this.gameLogger.previousGames[this.currentGameIndex]; // Use current game index

                        // Check if this game is valid
                        if (selectedGame && selectedGame.moves && selectedGame.moves.length > 0 &&
                            selectedGame.boards && selectedGame.boards.length > 0) {

                            // Set up game state
                            this.isRolling = true;
                            this.currentMoveIndex = Math.max(0, Math.min(startIndex, selectedGame.moves.length - 1));
                            this.targetEndIndex = (endIndex < 0) ? selectedGame.moves.length - 1 :
                                Math.min(endIndex, selectedGame.moves.length - 1);

                            // Create custom display state function for previousGames data
                            const displayState = () => {
                                const currentBoard = selectedGame.boards[this.currentMoveIndex];
                                if (currentBoard) {
                                    this.gameBoard.setBoard(currentBoard);

                                    // Update current player indicator
                                    const currentPlayer = selectedGame.players[this.currentMoveIndex];
                                    this.gameBoard.updatePlayerIndicator(currentPlayer);

                                    // Highlight move position (if available)
                                    if (this.currentMoveIndex >= 0) {
                                        const move = selectedGame.moves[this.currentMoveIndex];
                                        if (move && move.position) {
                                            this.gameBoard.highlightCell(move.position.row, move.position.col);
                                        }
                                    }
                                }
                            };

                            // Display initial state
                            displayState();

                            // Override _displayCurrentState method temporarily
                            const originalDisplayState = this._displayCurrentState;
                            this._displayCurrentState = displayState;

                            // Schedule next moves
                            this._scheduleNextMove();

                            return true;
                        }
                    }

                    console.warn("No game logs available for rollout.");
                    return false;
                }

                // Original code for when current logs are available
                this.analyzeGameBoundaries();
                this.isRolling = true;
                this.currentMoveIndex = Math.max(0, Math.min(startIndex, logs.moves.length - 1));
                this.targetEndIndex = (endIndex < 0) ? logs.moves.length - 1 : Math.min(endIndex, logs.moves.length - 1);
                this._displayCurrentState();
                this._scheduleNextMove();
                return true;
            }

            // Stop rollout
            stop() {
                if (this.rolloutTimer) {
                    clearTimeout(this.rolloutTimer);
                    this.rolloutTimer = null;
                }
                this.isRolling = false;
                return this.currentMoveIndex;
            }

            // Pause rollout
            pause() {
                if (this.rolloutTimer) {
                    clearTimeout(this.rolloutTimer);
                    this.rolloutTimer = null;
                }
                this.isRolling = false;
                return this.currentMoveIndex;
            }

            // Resume rollout
            resume() {
                if (!this.isRolling && this.currentMoveIndex >= 0) {
                    this.isRolling = true;
                    this._scheduleNextMove();
                    return true;
                }
                return false;
            }

            // Set rollout speed
            setSpeed(speedInMs) {
                this.rolloutSpeed = Math.max(2, speedInMs); // Minimum speed 100ms
                return this.rolloutSpeed;
            }

            jumpToMove(moveIndex) {
                const logs = this.gameLogger.getLogs();
                const usePreviousGame = !logs || !logs.moves || logs.moves.length === 0;

                if (moveIndex === -1) {
                    this.currentMoveIndex = -1;

                    if (usePreviousGame && this.gameLogger.previousGames &&
                        this.gameLogger.previousGames.length > 0) {
                        // 초기 보드 상태 표시 (첫 번째 보드를 사용)
                        const selectedGame = this.gameLogger.previousGames[this.currentGameIndex];
                        if (selectedGame && selectedGame.boards && selectedGame.boards.length > 0) {
                            const firstBoard = selectedGame.boards[0];
                            this.gameBoard.setBoard(firstBoard);
                            updateRolloutControls();
                            return true;
                        }
                    }
                }

                if (usePreviousGame) {
                    // Using previousGames data
                    if (this.gameLogger.previousGames && this.gameLogger.previousGames.length > 0) {
                        const selectedGame = this.gameLogger.previousGames[this.currentGameIndex]; // Use current game index
                        if (selectedGame && selectedGame.moves && moveIndex >= 0 && moveIndex < selectedGame.moves.length) {
                            this.currentMoveIndex = moveIndex;

                            // Display state using previousGames data
                            const currentBoard = selectedGame.boards[this.currentMoveIndex];
                            if (currentBoard) {
                                this.gameBoard.setBoard(currentBoard);

                                // Update current player indicator
                                const currentPlayer = selectedGame.players[this.currentMoveIndex];
                                this.gameBoard.updatePlayerIndicator(currentPlayer);

                                // Highlight move position (if available)
                                if (this.currentMoveIndex >= 0) {
                                    const move = selectedGame.moves[this.currentMoveIndex];
                                    if (move && move.position) {
                                        this.gameBoard.highlightCell(move.position.row, move.position.col);
                                    }
                                }
                            }
                            return true;
                        }
                    }
                    return false;
                } else {
                    // Original code
                    if (!logs || !logs.moves || moveIndex < 0 || moveIndex >= logs.moves.length) {
                        return false;
                    }

                    this.currentMoveIndex = moveIndex;
                    this._displayCurrentState();
                    return true;
                }
            }



            next() {
                // Get logs (either current or from previousGames)
                const logs = this.gameLogger.getLogs();
                const usePreviousGame = !logs || !logs.moves || logs.moves.length === 0;

                if (usePreviousGame) {
                    // Using previousGames data
                    if (this.gameLogger.previousGames && this.gameLogger.previousGames.length > 0) {
                        const selectedGame = this.gameLogger.previousGames[this.currentGameIndex]; // Use current game index
                        if (selectedGame && selectedGame.moves && this.currentMoveIndex < selectedGame.moves.length - 1) {
                            this.currentMoveIndex++;

                            // Display state using previousGames data
                            const currentBoard = selectedGame.boards[this.currentMoveIndex];
                            if (currentBoard) {
                                this.gameBoard.setBoard(currentBoard);

                                // Update current player indicator
                                const currentPlayer = selectedGame.players[this.currentMoveIndex];
                                this.gameBoard.updatePlayerIndicator(currentPlayer);

                                // Highlight move position (if available)
                                if (this.currentMoveIndex >= 0) {
                                    const move = selectedGame.moves[this.currentMoveIndex];
                                    if (move && move.position) {
                                        this.gameBoard.highlightCell(move.position.row, move.position.col);
                                    }
                                }
                            }
                            return true;
                        }
                    }
                    return false;
                } else {
                    // Original code for current logs
                    if (this.currentMoveIndex < logs.moves.length - 1) {
                        this.currentMoveIndex++;
                        this._displayCurrentState();
                        return true;
                    }
                    return false;
                }
            }

            previous() {
                // Get logs (either current or from previousGames)
                const logs = this.gameLogger.getLogs();
                const usePreviousGame = !logs || !logs.moves || logs.moves.length === 0;

                if (usePreviousGame) {
                    // Using previousGames data
                    if (this.gameLogger.previousGames && this.gameLogger.previousGames.length > 0) {
                        const selectedGame = this.gameLogger.previousGames[this.currentGameIndex]; // Use current game index
                        if (selectedGame && selectedGame.moves && this.currentMoveIndex > 0) {
                            this.currentMoveIndex--;

                            // Display state using previousGames data
                            const currentBoard = selectedGame.boards[this.currentMoveIndex];
                            if (currentBoard) {
                                this.gameBoard.setBoard(currentBoard);

                                // Update current player indicator
                                const currentPlayer = selectedGame.players[this.currentMoveIndex];
                                this.gameBoard.updatePlayerIndicator(currentPlayer);

                                // Highlight move position (if available)
                                if (this.currentMoveIndex >= 0) {
                                    const move = selectedGame.moves[this.currentMoveIndex];
                                    if (move && move.position) {
                                        this.gameBoard.highlightCell(move.position.row, move.position.col);
                                    }
                                }
                            }
                            return true;
                        }
                    }
                    return false;
                } else {
                    // Original code for current logs
                    if (this.currentMoveIndex > 0) {
                        this.currentMoveIndex--;
                        this._displayCurrentState();
                        return true;
                    }
                    return false;
                }
            }

            // Display current state (internal helper method)
            _displayCurrentState() {
                const board = this.gameLogger.getBoardAtMove(this.currentMoveIndex);
                if (board) {
                    this.gameBoard.setBoard(board);
                    // Update UI for current player
                    const currentPlayer = this.gameLogger.getPlayerAtMove(this.currentMoveIndex);
                    this.gameBoard.updatePlayerIndicator(currentPlayer);

                    // Highlight move position (optional)
                    if (this.currentMoveIndex >= 0) {
                        const move = this.gameLogger.getLogs().moves[this.currentMoveIndex];
                        if (move && move.position) {
                            this.gameBoard.highlightCell(move.position.row, move.position.col);
                        }
                    }
                }
            }

            // Schedule next move (internal helper method)
            _scheduleNextMove() {
                if (!this.isRolling) return;

                if (this.currentMoveIndex < this.targetEndIndex) {
                    this.rolloutTimer = setTimeout(() => {
                        this.next();

                        const moveSlider = document.getElementById('rollout-moves');
                        if (moveSlider) {
                            moveSlider.value = this.currentMoveIndex;
                        }
                        updateRolloutControls();

                        this._scheduleNextMove();
                    }, this.rolloutSpeed);
                } else {
                    this.isRolling = false;
                }
            }

            // Get current rollout status
            getStatus() {
                const logs = this.gameLogger.getLogs();

                // Calculate current game-specific turn information
                const currentGameTurn = this.getCurrentGameTurn();
                if (this.currentMoveIndex === -1) {
                    currentGameTurn = 0;
                }
                const totalTurnsInCurrentGame = this.getCurrentGameTotalTurns();

                return {
                    isPlaying: this.isRolling,
                    currentMove: this.currentMoveIndex,
                    totalMoves: logs && logs.moves ? logs.moves.length : 0,
                    speed: this.rolloutSpeed,
                    progress: logs && logs.moves && logs.moves.length > 0 ?
                        ((this.currentMoveIndex + 1) / logs.moves.length) * 100 : 0,
                    // Add game-specific turn information
                    currentGameTurn: currentGameTurn,
                    totalTurnsInCurrentGame: totalTurnsInCurrentGame,
                    currentGameIndex: this.currentGameIndex
                };
            }

            nextGame() {
                if (this.gameLogger.previousGames &&
                    this.currentGameIndex < this.gameLogger.previousGames.length - 1) {
                    this.currentGameIndex++;
                    this.currentMoveIndex = -1; // Set to -1 to show Turn 0/N

                    // Get stage config from metadata
                    const selectedGame = this.gameLogger.previousGames[this.currentGameIndex];
                    let stageConfig = null;

                    if (selectedGame && selectedGame.metadata && selectedGame.metadata.stage) {
                        const stageName = selectedGame.metadata.stage;
                        stageConfig = stages.find(s => s.name === stageName) || stages[0];
                    }

                    // Create and set initial board state
                    const initialBoard = createInitialBoard(stageConfig);
                    this.gameBoard.setBoard(initialBoard);

                    // Display log for the current selected game
                    const logInput = document.getElementById('log-input');
                    if (logInput && selectedGame) {
                        // Use stored log text if available
                        if (selectedGame.logText) {
                            logInput.value = selectedGame.logText;
                        }
                        // If no log text, generate from metadata
                        else if (selectedGame.metadata) {
                            logInput.value = `Game ${this.currentGameIndex + 1}: ${selectedGame.metadata.blackStrategy}(B) vs ${selectedGame.metadata.whiteStrategy}(W) on ${selectedGame.metadata.stage}`;
                        }
                    }

                    // Update UI
                    updateRolloutControls();
                    return true;
                }
                return false;
            }

            previousGame() {
                if (this.gameLogger.previousGames && this.currentGameIndex > 0) {
                    this.currentGameIndex--;
                    this.currentMoveIndex = -1; // Set to -1 to show Turn 0/N

                    // Get stage config from metadata
                    const selectedGame = this.gameLogger.previousGames[this.currentGameIndex];
                    let stageConfig = null;

                    if (selectedGame && selectedGame.metadata && selectedGame.metadata.stage) {
                        const stageName = selectedGame.metadata.stage;
                        stageConfig = stages.find(s => s.name === stageName) || stages[0];
                    }

                    // Create and set initial board state
                    const initialBoard = createInitialBoard(stageConfig);
                    this.gameBoard.setBoard(initialBoard);

                    // Display log for the current selected game
                    const logInput = document.getElementById('log-input');
                    if (logInput && selectedGame) {
                        // Use stored log text if available
                        if (selectedGame.logText) {
                            logInput.value = selectedGame.logText;
                        }
                        // If no log text, generate from metadata
                        else if (selectedGame.metadata) {
                            logInput.value = `Game ${this.currentGameIndex + 1}: ${selectedGame.metadata.blackStrategy}(B) vs ${selectedGame.metadata.whiteStrategy}(W) on ${selectedGame.metadata.stage}`;
                        }
                    }

                    // Update UI
                    updateRolloutControls();
                    return true;
                }
                return false;
            }


            // nextGame() {
            //     if (this.gameLogger.previousGames &&
            //         this.currentGameIndex < this.gameLogger.previousGames.length - 1) {
            //         this.currentGameIndex++;
            //         this.currentMoveIndex = -1; // Set to -1 to show Turn 0/N

            //         // Get stage config from metadata
            //         const selectedGame = this.gameLogger.previousGames[this.currentGameIndex];
            //         let stageConfig = null;

            //         if (selectedGame && selectedGame.metadata && selectedGame.metadata.stage) {
            //             const stageName = selectedGame.metadata.stage;
            //             stageConfig = stages.find(s => s.name === stageName) || stages[0];
            //         }

            //         // Create and set initial board state
            //         const initialBoard = createInitialBoard(stageConfig);
            //         this.gameBoard.setBoard(initialBoard);

            //         // Update UI
            //         updateRolloutControls();
            //         return true;
            //     }
            //     return false;
            // }

            // previousGame() {
            //     if (this.gameLogger.previousGames && this.currentGameIndex > 0) {
            //         this.currentGameIndex--;
            //         this.currentMoveIndex = -1; // Set to -1 to show Turn 0/N

            //         // Get stage config from metadata
            //         const selectedGame = this.gameLogger.previousGames[this.currentGameIndex];
            //         let stageConfig = null;

            //         if (selectedGame && selectedGame.metadata && selectedGame.metadata.stage) {
            //             const stageName = selectedGame.metadata.stage;
            //             stageConfig = stages.find(s => s.name === stageName) || stages[0];
            //         }

            //         // Create and set initial board state
            //         const initialBoard = createInitialBoard(stageConfig);
            //         this.gameBoard.setBoard(initialBoard);

            //         // Update UI
            //         updateRolloutControls();
            //         return true;
            //     }
            //     return false;
            // }

            getCurrentGameInfo() {
                return {
                    gameIndex: this.currentGameIndex,
                    totalGames: this.gameStartIndices.length,
                    currentTurn: this.getCurrentGameTurn(),
                    totalTurns: this.getCurrentGameTotalTurns()
                };
            }
        }


        // --- Game State Functions ---
        // Add this function to determine next player based on piece count
        function determineNextPlayer() {
            // Check if the current stage has the fewerPiecesContinue rule
            const stageConfig = currentStage || stages[0];
            const fewerPiecesContinue = stageConfig.fewerPiecesContinue || false;

            // If rule isn't active, just alternate turns as usual
            if (!fewerPiecesContinue) {
                return currentPlayer === BLACK ? WHITE : BLACK;
            }

            // Count pieces for each player
            const scores = countDiscs();

            // Determine who has fewer pieces
            if (scores.black < scores.white) {
                return BLACK; // Black has fewer pieces, so Black plays again
            } else if (scores.white < scores.black) {
                return WHITE; // White has fewer pieces, so White plays again
            } else {
                // Equal number of pieces, alternate turns
                return currentPlayer === BLACK ? WHITE : BLACK;
            }
        }

        // 9. Modify updateStatus function (to accept the winner as an argument)
        function updateStatus(winner = null) {
            const s = countDiscs();

            if (gameRunning) {
                const ctrl = currentPlayer === BLACK ? blackAISelect.value : whiteAISelect.value;
                const pDisp = getPlayerName(currentPlayer);

                // Default status message
                statusElement.textContent = `${pDisp}'s turn (${s.black}-${s.white})`;

                // Add time display (optional)
                const blackTime = (blackTimeUsed / 1000).toFixed(1);
                const whiteTime = (whiteTimeUsed / 1000).toFixed(1);
                statusElement.textContent += ` [B:${blackTime}s W:${whiteTime}s]`;

                // Indicate if continuing due to fewer pieces rule
                const stageConfig = currentStage || stages[0];
                if (stageConfig.fewerPiecesContinue) {
                    const playerHasFewerPieces =
                        (currentPlayer === BLACK && s.black < s.white) ||
                        (currentPlayer === WHITE && s.white < s.black);

                    if (playerHasFewerPieces) {
                        statusElement.textContent += " (continuing - fewer pieces)";
                    }
                }

                // Apply styling
                statusElement.className = 'status ' + (ctrl === 'human' ? '' : 'thinking');
                statusElement.style.backgroundColor = ctrl === 'human' ?
                    (currentPlayer === BLACK ? '#333' : '#999') : '#FFC107';
            } else {
                // Game over state
                let msg = `Game over. `;

                // If loss was due to timeout
                if (winner !== null) {
                    const winnerName = winner === BLACK ? "Black" : "White";
                    msg += `${winnerName} wins! (${s.black}-${s.white})`;

                    // Show timeout forfeit (optional)
                    if ((winner === BLACK && whiteTimeUsed > MAX_AI_TIME_PER_GAME) ||
                        (winner === WHITE && blackTimeUsed > MAX_AI_TIME_PER_GAME)) {
                        msg += " (by time forfeit)";
                    }
                } else {
                    // Normal game end
                    if (s.black > s.white) msg += `Black wins! (${s.black}-${s.white})`;
                    else if (s.white > s.black) msg += `White wins! (${s.black}-${s.white})`;
                    else msg += `Tie! (${s.black}-${s.white})`;
                }

                statusElement.textContent = msg;
                statusElement.style.backgroundColor = '#666';
            }

            // Update timers
            updateTimers();
        }

        function displayGameLogInReplay(isTournament = false) {
            try {
                const logInput = document.getElementById('log-input');
                if (!logInput || !window.gameLogger) {
                    console.warn("Failed to display log: Required elements not found.");
                    return;
                }

                // Get previous games logs
                const previousGames = window.gameLogger.previousGames || [];
                const gameLogs = [];

                // Debug log to check the content
                console.log("Previous games count:", previousGames.length);
                if (previousGames.length > 0) {
                    console.log("First game logText:", previousGames[0].logText);
                    console.log("First game metadata:", previousGames[0].metadata);
                }

                // Add stored log text from each previous game
                previousGames.forEach((game, index) => {
                    if (game.logText && game.logText.trim() !== "") {
                        // Use the stored complete log text
                        gameLogs.push(game.logText);
                    } else if (game.metadata) {
                        // If logText is missing but we have metadata and moves, generate a log text
                        let generatedLog = `Game started: ${game.metadata.blackStrategy}(B) vs ${game.metadata.whiteStrategy}(W) on Stage: ${game.metadata.stage}\n`;

                        // Add moves if available
                        if (game.moves && game.moves.length > 0) {
                            const colLabels = 'abcdefghijklmnopqrstuvwxyz';
                            game.moves.forEach(move => {
                                if (move && move.player && move.position) {
                                    const playerName = move.player === 1 ? game.metadata.blackStrategy : game.metadata.whiteStrategy;
                                    const colorIndicator = move.player === 1 ? "(B)" : "(W)";
                                    const col = colLabels[move.position.col];
                                    const row = move.position.row + 1;
                                    generatedLog += `${playerName}${colorIndicator}: ${col}${row}\n`;
                                }
                            });
                        }

                        // Add result
                        if (game.metadata.blackScore !== undefined && game.metadata.whiteScore !== undefined) {
                            generatedLog += `Game over: Final score ${game.metadata.blackScore}-${game.metadata.whiteScore}\n`;
                            if (game.metadata.blackScore > game.metadata.whiteScore) {
                                generatedLog += "Black wins!";
                            } else if (game.metadata.whiteScore > game.metadata.blackScore) {
                                generatedLog += "White wins!";
                            } else {
                                generatedLog += "It's a tie!";
                            }
                        }

                        gameLogs.push(generatedLog);
                    }
                });

                // Add current game log if one is in progress
                const currentLogs = window.gameLogger.getLogs();
                if (currentLogs && currentLogs.moves && currentLogs.moves.length > 0) {
                    const currentGameLog = generateHumanReadableLog(window.gameLogger);
                    if (currentGameLog && currentGameLog !== "No game log data available.") {
                        gameLogs.push(currentGameLog);
                    }
                }

                // Display all logs
                if (gameLogs.length > 0) {
                    logInput.value = gameLogs.join("\n\n");

                    // Update GameRollout if available
                    if (window.gameRollout) {
                        window.gameRollout.analyzeGameBoundaries();
                        updateRolloutControls();
                    }
                } else {
                    logInput.value = "No game logs available.";
                }
            } catch (e) {
                console.error("Error displaying game logs:", e);
            }
        }


        /**
         * End the current game and record results
         * @param {number} winner - The winning player (BLACK, WHITE, or null for tie)
         */
        function endGame(winner = null) {
            if (!gameRunning) return;
            gameRunning = false;
            startButton.disabled = false;

            const s = countDiscs();

            // Determine winner if not provided
            if (winner === null) {
                if (s.black > s.white) winner = BLACK;
                else if (s.white > s.black) winner = WHITE;
            }

            updateStatus(winner);

            // Add final result to the game log
            if (!moveLog.some(l => l.startsWith('Game over:'))) {
                logMessage(`Game over: Final score ${s.black}-${s.white}`);

                if (winner === BLACK) {
                    logMessage(`Black wins!`);
                } else if (winner === WHITE) {
                    logMessage(`White wins!`);
                } else {
                    logMessage(`Tie!`);
                }
            }

            // Save complete game data with log
            if (window.gameLogger) {
                try {
                    // Get strategy names from the UI at the moment the game ends
                    const blackName = blackAISelect.options[blackAISelect.selectedIndex].text;
                    const whiteName = whiteAISelect.options[whiteAISelect.selectedIndex].text;

                    console.log(`Ending game: ${blackName}(B) vs ${whiteName}(W) on ${currentStage.name}`);

                    // Save the game with all current information
                    window.gameLogger.saveGameWithLog(
                        s.black,
                        s.white,
                        blackName,
                        whiteName,
                        currentStage,
                        moveLog // Pass the complete move log for storage
                    );

                    // Added here: After saving the game, display the most recent game
                    if (window.gameRollout && window.gameLogger.previousGames.length > 0) {
                        // Set index to the last game
                        const lastGameIndex = window.gameLogger.previousGames.length - 1;
                        window.gameRollout.currentGameIndex = lastGameIndex;
                        window.gameRollout.currentMoveIndex = -1; // Set to Turn 0

                        // Get the last game
                        const lastGame = window.gameLogger.previousGames[lastGameIndex];

                        // Update the log display
                        const logInput = document.getElementById('log-input');
                        if (logInput && lastGame) {
                            if (lastGame.logText) {
                                logInput.value = lastGame.logText;
                            } else if (lastGame.metadata) {
                                logInput.value = `Game ${lastGameIndex + 1}: ${lastGame.metadata.blackStrategy}(B) vs ${lastGame.metadata.whiteStrategy}(W) on ${lastGame.metadata.stage}`;
                            }
                        }

                        // Update UI controls
                        updateRolloutControls();

                        console.log(`GameRollout updated to show last game (${lastGameIndex + 1})`);
                    }
                } catch (e) {
                    console.error("Error saving game with log:", e);
                }
            }
        }


        // New function to update game log in replay without scrolling
        function updateGameLogInReplay(isTournament = false) {
            const logInput = document.getElementById('log-input');
            if (!logInput || !window.gameLogger) {
                console.warn("Failed to update game log: Required elements not found.");
                return;
            }

            // Generate and display human-readable log
            const logText = generateHumanReadableLog(window.gameLogger);

            // Only update if we have actual log content
            if (logText.trim() !== "") {
                // Display log in the textarea
                logInput.value = logText;

                // Update GameRollout if available
                if (window.gameRollout) {
                    try {
                        window.gameRollout.analyzeGameBoundaries();
                        updateRolloutControls();
                        console.log("GameRollout updated successfully");
                    } catch (e) {
                        console.error("Error updating GameRollout:", e);
                    }
                }
            } else {
                console.warn("No log content to display");
            }
        }

        async function startGame(isTournament = false, stageConfig = null) {
            console.log("[startGame] Start.");
            const selectedStage = stageConfig || (stages[stageSelect.value] || stages[0]);
            if (!selectedStage) { alert("Please select a valid stage."); return; }

            if (!isTournament && window.gameLogger) {
                console.log("[startGame] Resetting game logger for new game");
                window.gameLogger.moves = [];
                window.gameLogger.boardStates = [];
                window.gameLogger.currentPlayer = [];
                window.gameLogger.capturedCounts = [];
            }

            // initializeBoard는 isPreview=false로 호출되어 gameOver=false로 설정합니다.
            initializeBoard(selectedStage, false);

            gameRunning = true;
            blackTimeUsed = 0;
            whiteTimeUsed = 0;
            currentPlayer = BLACK;
            moveLog = [];
            gameStartLogged = false;

            if (!isTournament) { gameLogElement.innerHTML = ''; }

            startButton.disabled = true;
            updateStatus();
            updateBoardDisplay();
            const blackName = blackAISelect.options[blackAISelect.selectedIndex].text;
            const whiteName = whiteAISelect.options[whiteAISelect.selectedIndex].text;
            logMessage(`Game started: ${blackName}(B) vs ${whiteName}(W) on Stage: ${selectedStage.name}`);

            console.log(`[startGame] Before setTimeout: gameRunning=<span class="math-inline">\{gameRunning\}, gameOver\=</span>{gameOver}`);

            // Check if the first player (Black) is human and has no valid moves at the start
            if (blackAISelect.value === 'human') {
                const humanMoves = getValidMoves(BLACK);
                if (humanMoves.length === 0) {
                    console.log("Starting human player has no valid moves. Passing automatically.");
                    logPass(BLACK);
                    currentPlayer = WHITE;
                    updateStatus();
                }
            }

            setTimeout(() => {

                console.log(`[startGame -> setTimeout] Inside callback: gameRunning=<span class="math-inline">\{gameRunning\}, gameOver\=</span>{gameOver}`);
                if (!gameRunning || gameOver) {
                    console.warn("[startGame -> setTimeout] Game ended before first move check.");
                    return;
                }
                console.log("[startGame -> setTimeout] Triggering first move check...");
                makeAIMove(isTournament); // Start moves (will check if P1 is AI or Human)
            }, 10);
            console.log("[startGame] Finish initial setup. First move check scheduled.");
        }
        function resetGame() { /* ... Uses stageConfig for preview ... */ console.log("[resetGame] Function called!"); gameRunning = false; if (gameLoopTimeout) clearTimeout(gameLoopTimeout); gameLoopTimeout = null; aiThinking = false; const idx = stageSelect.value; const selStage = (idx >= 0 && idx < stages.length) ? stages[idx] : stages[0]; initializeBoard(selStage, true); currentPlayer = BLACK; moveLog = ["Board reset."]; updateGameLog(); startButton.disabled = false; statusElement.textContent = "Ready to start."; statusElement.style.backgroundColor = '#4CAF50'; }


        // --- Strategy Management Functions ---
        // saveStrategy, clearEditor, loadStrategy, deleteStrategy, updateStrategyList, uploadStrategyFiles, finishUpload, loadSavedStrategies, updateAISelectors, getCompiledStrategy
        // (Largely same as before, adapted for Othello variables)
        function saveStrategy() { const n = strategyNameInput.value.trim(); const c = jsCodeElement.value; if (!n) return alert("Name?"); if (!c) return alert("Code?"); if (!c.includes('studentStrategy') && !c.includes('function(')) console.warn("Code might not be valid"); savedStrategies[n] = c; localStorage.setItem('othelloStrategies', JSON.stringify(savedStrategies)); compiledStudentAIs[n] = null; updateStrategyList(); updateAISelectors(); statusElement.textContent = `Saved "${n}".`; statusElement.style.backgroundColor = '#4CAF50'; }
        function clearEditor() { jsCodeElement.value = ''; strategyNameInput.value = 'myOthelloStrategy'; }
        function loadStrategy(n) { if (savedStrategies[n]) { jsCodeElement.value = savedStrategies[n]; strategyNameInput.value = n; statusElement.textContent = `Loaded "${n}".`; } }
        function deleteStrategy(n) { if (confirm(`Delete "${n}"?`)) { delete savedStrategies[n]; delete compiledStudentAIs[n]; localStorage.setItem('othelloStrategies', JSON.stringify(savedStrategies)); updateStrategyList(); updateAISelectors(); statusElement.textContent = `Deleted "${n}".`; statusElement.style.backgroundColor = '#f44336'; } }
        function updateStrategyList() { strategyListElement.innerHTML = ''; const nms = Object.keys(savedStrategies); if (nms.length === 0) { strategyListElement.innerHTML = '<div class="strategy-item"><span>No saved strategies</span></div>'; return; } nms.sort().forEach(n => { const i = document.createElement('div'); i.className = 'strategy-item'; const s = document.createElement('span'); s.textContent = n; i.appendChild(s); const b = document.createElement('div'); b.className = 'buttons'; const lB = document.createElement('button'); lB.textContent = 'Edit'; lB.onclick = () => loadStrategy(n); b.appendChild(lB); const dB = document.createElement('button'); dB.textContent = 'Delete'; dB.className = 'delete-btn'; dB.onclick = () => deleteStrategy(n); b.appendChild(dB); i.appendChild(b); strategyListElement.appendChild(i); }); }
        function uploadStrategyFiles() { const files = strategyFileInput.files; if (files.length === 0) return alert('Select files'); uploadStatusMsg.textContent = `Processing ${files.length}...`; uploadStatusMsg.className = 'upload-status'; uploadStatusMsg.style.display = 'block'; let sC = 0, eC = 0; Array.from(files).forEach((f, idx) => { const r = new FileReader(); r.onload = (e) => { try { const c = e.target.result; const n = f.name.replace(/\.js$/, ''); if (!c || !n) throw new Error("Empty"); if (!c.includes('studentStrategy') && !c.includes('function(')) console.warn(`File ${f.name} might not be valid.`); savedStrategies[n] = c; compiledStudentAIs[n] = null; sC++; } catch (err) { eC++; console.error(`File ${f.name} Err:`, err); } if (sC + eC === files.length) finishUpload(sC, eC); }; r.onerror = () => { eC++; if (sC + eC === files.length) finishUpload(sC, eC); }; r.readAsText(f); }); }
        function finishUpload(sC, eC) { localStorage.setItem('othelloStrategies', JSON.stringify(savedStrategies)); updateStrategyList(); updateAISelectors(); strategyFileInput.value = ''; let msg = '', cls = 'upload-status '; if (eC === 0) { msg = `Uploaded ${sC} strategies!`; cls += 'upload-success'; } else { msg = `${sC} OK, ${eC} Fail.`; cls += (sC > 0 ? '' : 'upload-error'); } uploadStatusMsg.textContent = msg; uploadStatusMsg.className = cls; setTimeout(() => { uploadStatusMsg.style.display = 'none'; }, 4800); statusElement.textContent = msg; statusElement.style.backgroundColor = eC === 0 ? '#4CAF50' : '#FF9800'; }
        function loadSavedStrategies() { const d = localStorage.getItem('othelloStrategies'); if (d) { try { savedStrategies = JSON.parse(d); } catch (e) { console.error("Err load strats", e); savedStrategies = {}; } } else { savedStrategies = {}; } compiledStudentAIs = {}; updateStrategyList(); }
        // *** updateAISelectors Corrected for Othello ***
        function updateAISelectors() {
            console.log("[updateAISelectors] Populating Othello selectors...");
            const bV = blackAISelect.value;
            const wV = whiteAISelect.value;
            blackAISelect.innerHTML = '';
            whiteAISelect.innerHTML = '';

            // Add Human option
            const humanOptB = document.createElement('option');
            humanOptB.value = 'human';
            humanOptB.textContent = 'Human';
            blackAISelect.appendChild(humanOptB);

            const humanOptW = document.createElement('option');
            humanOptW.value = 'human';
            humanOptW.textContent = 'Human';
            whiteAISelect.appendChild(humanOptW);

            try {
                // Add built-in strategies
                const builtInOptG = document.createElement('optgroup');
                builtInOptG.label = "Built-in AI";

                const builtInN = Object.keys(builtInStrategies).filter(k => k !== 'custom').sort();
                if (builtInN.length > 0) {
                    builtInN.forEach(n => {
                        const opt = document.createElement('option');
                        opt.value = n;
                        opt.textContent = n.charAt(0).toUpperCase() + n.slice(1);
                        builtInOptG.appendChild(opt);
                    });

                    blackAISelect.appendChild(builtInOptG.cloneNode(true));
                    whiteAISelect.appendChild(builtInOptG.cloneNode(true));
                }
            } catch (e) {
                console.error("Error adding built-in AIs:", e);
            }

            try {
                // Add custom strategies
                const customN = Object.keys(savedStrategies).sort();
                if (customN.length > 0) {
                    const customOptG = document.createElement('optgroup');
                    customOptG.label = "Custom Strategies";

                    customN.forEach(n => {
                        const opt = document.createElement('option');
                        opt.value = `custom_${n}`;
                        opt.textContent = n;
                        customOptG.appendChild(opt);
                    });

                    blackAISelect.appendChild(customOptG.cloneNode(true));
                    whiteAISelect.appendChild(customOptG.cloneNode(true));
                }
            } catch (e) {
                console.error("Error adding custom strategies:", e);
            }

            try {
                // Restore previously selected values if available
                blackAISelect.value = Array.from(blackAISelect.options).some(o => o.value === bV) ? bV : 'greedy';
                whiteAISelect.value = Array.from(whiteAISelect.options).some(o => o.value === wV) ? wV : 'corners';
            } catch (e) {
                console.error("Error restoring AI selector values:", e);
                blackAISelect.value = 'greedy';
                whiteAISelect.value = 'corners';
            }

            console.log("[updateAISelectors] Finished.");
        }
        // *** getCompiledStrategy for Othello (4 args) ***
        /**
         * Retrieves a compiled strategy function based on the controller ID.
         * Handles built-in strategies and custom strategies (both script-style and function-style).
         * Caches compiled custom strategies.
         *
         * Relies on outer scope variables:
         * - savedStrategies: Object mapping custom strategy names to their code strings.
         * - compiledStudentAIs: Object used as a cache for compiled custom functions.
         * - builtInStrategies: Object mapping built-in strategy IDs to their functions.
         *
         * @param {string} controllerId - The ID of the strategy (e.g., 'greedy', 'custom_myStrategy').
         * @param {number} player - The player ID (1 for Black, 2 for White). Although passed,
         * this specific function doesn't currently use it directly,
         * but it's kept for signature consistency with the calling code.
         * @returns {Function|null} The compiled strategy function or null if not found/error.
         */
        function getCompiledStrategy(controllerId, player) {
            // 1. Handle Custom Strategies (ID starts with 'custom_')
            if (controllerId.startsWith('custom_')) {
                const strategyName = controllerId.replace('custom_', '');

                // 1a. Check cache first for performance
                if (compiledStudentAIs[strategyName]) {
                    // console.log(`Using cached strategy: ${strategyName}`); // Optional debug log
                    return compiledStudentAIs[strategyName];
                }

                // 1b. Check if the strategy code exists in storage
                if (savedStrategies[strategyName]) {
                    console.log(`Compiling Othello strategy: ${strategyName}`);
                    const code = savedStrategies[strategyName]; // The raw code string

                    // 1c. Detect strategy type: Guess it's OLD script style if it LACKS "function studentStrategy"
                    const looksLikeOldScript = !code.includes('function studentStrategy');

                    let compiledFunc = null; // To hold the result of new Function()

                    // 1d. Use the appropriate wrapper based on detection
                    if (looksLikeOldScript) {
                        // --- Compile OLD SCRIPT-STYLE Strategy ---
                        console.log(`-> Using script-style wrapper for ${strategyName}`);
                        try {
                            // Create a function that simulates the old environment
                            compiledFunc = new Function('boardArg', 'playerArg', 'validMovesArg', 'makeMoveFunc', `
                            // Define variables the script expects ('board', 'player', 'getValidMoves')
                            const board = boardArg;
                            const player = playerArg;
                            // Provide 'getValidMoves' that returns the pre-calculated list
                            const getValidMoves = (p_ignored) => validMovesArg;

                            // --- Execute the user's script code ---
                            ${code}
                            // --- End of user's script code ---

                            // Assume the script calculated 'bestMove'. Return it.
                            // Add safety check in case 'bestMove' isn't defined.
                            if (typeof bestMove === 'undefined') {
                            console.warn("Script ${strategyName} finished, but 'bestMove' variable is undefined. Returning null.");
                            return null;
                            }
                            return bestMove;
                        `);
                        } catch (e) {
                            // Handle errors during script compilation or execution
                            console.error(`Compile/Exec Err (Script ${strategyName}):`, e);
                            return null; // Failed
                        }
                    } else {
                        // --- Compile NEW FUNCTION-STYLE Strategy (expects studentStrategy) ---
                        console.log(`-> Using function-style wrapper for ${strategyName}`);
                        try {
                            // Use the original wrapper that expects 'studentStrategy' to be defined
                            compiledFunc = new Function('boardArg', 'playerArg', 'validMovesArg', 'makeMoveFunc',
                                `${code}\nreturn studentStrategy(boardArg, playerArg, validMovesArg, makeMoveFunc);`);
                        } catch (e) {
                            // Handle errors during function compilation
                            console.error(`Compile Err (Function ${strategyName}):`, e);
                            return null; // Failed
                        }
                    }

                    // 1e. Cache the successfully compiled function and return it
                    if (compiledFunc) {
                        compiledStudentAIs[strategyName] = compiledFunc;
                        return compiledFunc;
                    }
                    // If compilation failed in try/catch, compiledFunc remains null, fall through to error

                } else {
                    // Code for the custom strategy name wasn't found
                    console.error(`Code not found for custom strategy: ${strategyName}`);
                    return null;
                }
            }
            // 2. Handle Built-In Strategies (Not 'custom_')
            else if (builtInStrategies[controllerId]) {
                // console.log(`Using built-in strategy: ${controllerId}`); // Optional debug log
                return builtInStrategies[controllerId];
            }

            // 3. Strategy ID Not Recognized (Neither custom nor built-in)
            console.error(`Strategy function not found or invalid ID: ${controllerId}`);
            return null;
        }

        // --- Intelligent System Functions ---
        function uploadIntelligentSystem() {
            const file = intelligentSystemFileInput.files[0];
            if (!file) {
                alert('Please select an intelligent system file to upload');
                return;
            }

            // Disable the button and provide initial feedback
            uploadIntelligentSystemButton.disabled = true;
            intelligentSystemStatus.textContent = `Reading file: ${file.name}...`;
            intelligentSystemStatus.style.display = 'block';
            intelligentSystemStatus.className = 'intelligent-system-status';

            // Initialize and display the progress bar
            intelligentSystemProgress.style.display = 'block';
            intelligentSystemProgressBar.style.width = '5%';

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    // Feedback for file reading completion
                    intelligentSystemStatus.textContent = `Validating file: ${file.name}...`;
                    intelligentSystemProgressBar.style.width = '15%';

                    const code = e.target.result;
                    const systemName = file.name.replace(/\.js$/, '');

                    // Validate code contains analyzeStage function
                    if (!code.includes('function analyzeStage') && !code.includes('analyzeStage =')) {
                        throw new Error("The intelligent system must implement an 'analyzeStage' function");
                    }

                    // Feedback for validation completion
                    intelligentSystemStatus.textContent = `System validated. Preparing analysis...`;
                    intelligentSystemProgressBar.style.width = '25%';

                    // Store the system code
                    intelligentSystems[systemName] = code;

                    // Clear any previously compiled versions
                    compiledIntelligentSystems[systemName] = null;

                    // Introduce a small delay to allow UI updates to be visible
                    await new Promise(resolve => setTimeout(resolve, 300));

                    // Run analysis for current stage
                    const selectedStageIndex = parseInt(stageSelect.value);
                    const selectedStage = stages[selectedStageIndex];

                    intelligentSystemStatus.textContent = `Starting analysis on ${selectedStage.name}... (This will take up to 60 seconds)`;
                    intelligentSystemProgressBar.style.width = '30%';

                    // Analyze the stage
                    await analyzeStageWithSystem(systemName, selectedStage);

                    // Save to localStorage
                    localStorage.setItem('othelloIntelligentSystems', JSON.stringify(intelligentSystems));

                    // Update selectors
                    updateAISelectors();

                } catch (error) {
                    console.error("Error uploading intelligent system:", error);
                    intelligentSystemStatus.textContent = `Error: ${error.message}`;
                    intelligentSystemStatus.style.display = 'block';
                    intelligentSystemStatus.className = 'intelligent-system-status upload-error';
                    intelligentSystemProgressBar.style.width = '0%';
                    uploadIntelligentSystemButton.disabled = false;
                }
            };

            reader.onerror = () => {
                intelligentSystemStatus.textContent = "Error reading file";
                intelligentSystemStatus.style.display = 'block';
                intelligentSystemStatus.className = 'intelligent-system-status upload-error';
                intelligentSystemProgressBar.style.width = '0%';
                uploadIntelligentSystemButton.disabled = false;
            };

            reader.readAsText(file);
        }


        async function analyzeStageWithSystem(systemName, stageConfig) {
            if (isIntelligentSystemAnalyzing) {
                console.warn("Another analysis is already in progress. Please wait.");
                intelligentSystemStatus.textContent = "Previous analysis is still running...";
                intelligentSystemStatus.className = 'intelligent-system-status upload-error';
                intelligentSystemStatus.style.display = 'block';
                return;
            }

            console.log(`[Main] Starting analysis process for system: ${systemName} on stage: ${stageConfig.name}`);
            isIntelligentSystemAnalyzing = true;
            currentAnalysisStage = stageConfig;

            // --- UI Setup ---
            intelligentSystemProgress.style.display = 'block';
            intelligentSystemProgressBar.style.width = '0%';
            intelligentSystemStatus.style.display = 'block';
            intelligentSystemStatus.textContent = `Preparing analysis for ${systemName} on ${stageConfig.name}...`;
            intelligentSystemStatus.className = 'intelligent-system-status';
            uploadIntelligentSystemButton.disabled = true;

            // --- Analysis Setup ---
            const startTime = Date.now(); // Record start time
            const analysisTimeout = 60000; // 60 seconds timeout
            let analysisTimedOut = false; // Flag to track timeout status

            // --- Progress Simulation ---
            let progress = 0;
            const progressInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                // Calculate progress based on time (up to 95%)
                progress = Math.min(95, Math.floor((elapsed / analysisTimeout) * 100));
                intelligentSystemProgressBar.style.width = `${progress}%`;

                // Show remaining time
                const remainingSeconds = Math.max(0, Math.ceil((analysisTimeout - elapsed) / 1000));
                intelligentSystemStatus.textContent = `Analyzing ${stageConfig.name} with ${systemName}... (${progress}%, ${remainingSeconds}s remaining)`;
            }, 500); // Update every 500ms

            // --- Hard timeout check ---
            // This interval will force timeout even if analysis function blocks CPU
            const hardTimeoutId = setInterval(() => {
                const currentTime = Date.now();
                if (currentTime - startTime >= analysisTimeout) {
                    console.warn(`[Main] Hard timeout triggered after ${analysisTimeout}ms`);

                    // Clean up intervals
                    clearInterval(hardTimeoutId);
                    clearInterval(progressInterval);

                    // Mark analysis as no longer running
                    isIntelligentSystemAnalyzing = false;
                    currentAnalysisStage = null;

                    // Set failure message with elapsed time
                    const elapsedSeconds = ((currentTime - startTime) / 1000).toFixed(1);
                    intelligentSystemStatus.textContent =
                        `Analysis timed out after ${elapsedSeconds}s (limit: ${analysisTimeout / 1000}s)`;
                    intelligentSystemStatus.className = 'intelligent-system-status upload-error';
                    intelligentSystemProgressBar.style.width = '100%';

                    // Re-enable button
                    uploadIntelligentSystemButton.disabled = false;

                    // Set flag to exit function
                    analysisTimedOut = true;
                }
            }, 200); // Check every 200 ms 

            let generatedStrategy = null;
            let analysisError = null; // Store any analysis errors

            try {
                // --- Compile the Intelligent System ---
                const analyzeFunction = compileIntelligentSystem(systemName);
                if (!analyzeFunction) {
                    throw new Error("Failed to compile intelligent system");
                }

                // --- Prepare Stage Data ---
                const analysisBoard = Array(stageConfig.boardSize).fill().map(() => Array(stageConfig.boardSize).fill(EMPTY));
                (stageConfig.initialBlocked || []).forEach(p => { if (isWithinBoard(p.r, p.c)) analysisBoard[p.r][p.c] = BLOCKED; });
                (stageConfig.initialPlayer1 || []).forEach(p => { if (isWithinBoard(p.r, p.c) && analysisBoard[p.r][p.c] === EMPTY) analysisBoard[p.r][p.c] = BLACK; });
                (stageConfig.initialPlayer2 || []).forEach(p => { if (isWithinBoard(p.r, p.c) && analysisBoard[p.r][p.c] === EMPTY) analysisBoard[p.r][p.c] = WHITE; });
                const initialValidMoves = getValidMoves(BLACK, analysisBoard); // Assuming Black starts

                // --- Setup Promises for Race ---
                const analysisPromise = new Promise((resolve) => {
                    try {
                        // Execute analysis function
                        console.log(`[Main] Executing analyzeFunction for ${systemName}...`);
                        const result = analyzeFunction(
                            stageConfig.name,
                            stageConfig.boardSize,
                            analysisBoard,
                            initialValidMoves
                        );
                        resolve(result); // Return result on success
                    } catch (execError) {
                        console.error(`[Main] Error during analyzeFunction execution:`, execError);
                        analysisError = execError;
                        resolve(null);
                    }
                });

                const timeoutPromise = new Promise((_, reject) => {
                    // This regular timeout may not work if CPU is blocked
                    setTimeout(() => {
                        console.log(`[Main] Regular timeout triggered after ${analysisTimeout}ms`);
                        reject(new Error(`Analysis timed out (${analysisTimeout / 1000}s)`));
                    }, analysisTimeout);
                });

                // --- Run the Race ---
                console.log(`[Main] Waiting for analysis result or timeout (${analysisTimeout}ms)...`);

                // Stop early if hard timeout was triggered
                if (!analysisTimedOut) {
                    generatedStrategy = await Promise.race([analysisPromise, timeoutPromise]);
                    console.log(`[Main] Promise.race completed.`);
                }

                // Clean up the hard timeout
                clearInterval(hardTimeoutId);

                // Exit if hard timeout was triggered
                if (analysisTimedOut) {
                    return;
                }

            } catch (error) {
                // Promise.race rejected (typically timeout)
                console.error(`[Main] Promise.race failed:`, error.message);
                analysisError = error;
                generatedStrategy = null;

                // Clean up the hard timeout
                clearInterval(hardTimeoutId);

                // Exit if hard timeout was triggered
                if (analysisTimedOut) {
                    return;
                }

            } finally {
                // --- Final time check ---
                const endTime = Date.now();
                const elapsedTime = endTime - startTime;
                console.log(`[Main] Final check: Elapsed time = ${elapsedTime}ms`);

                // If we exceeded timeout but didn't trigger hard timeout yet
                if (!analysisTimedOut && elapsedTime > analysisTimeout) {
                    console.warn(`[Main] Analysis took too long (${elapsedTime}ms), exceeding timeout (${analysisTimeout}ms). Discarding result.`);
                    generatedStrategy = null;
                    analysisError = new Error(`Analysis exceeded timeout limit (${elapsedTime}ms > ${analysisTimeout}ms)`);
                }

                // Clean up any intervals that might still be running
                clearInterval(progressInterval);
            }

            // --- Process Result ---
            if (generatedStrategy && typeof generatedStrategy === 'function' && !analysisTimedOut) {
                // Success: Valid strategy function and didn't timeout
                try {
                    // Calculate elapsed time
                    const elapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);

                    console.log("[Main] Analysis successful. Compiling and saving strategy.");
                    const strategyCodeString = generatedStrategy.toString();
                    const finalStrategyCode = `function studentStrategy(board, player, validMoves, makeMove) {
                // Strategy generated by ${systemName} for ${stageConfig.name}
                const generatedFunc = (${strategyCodeString});
                return generatedFunc(board, player, validMoves, makeMove);
            }`;

                    // Quick validation check
                    new Function('board', 'player', 'validMoves', 'makeMove', `return (${finalStrategyCode})(board, player, validMoves, makeMove);`);

                    const generatedStrategyName = `${systemName}_${stageConfig.name.replace(/\s+/g, '_')}`;
                    savedStrategies[generatedStrategyName] = finalStrategyCode;
                    compiledStudentAIs[generatedStrategyName] = null;
                    localStorage.setItem('othelloStrategies', JSON.stringify(savedStrategies));

                    // Update UI
                    updateStrategyList();
                    updateAISelectors();
                    intelligentSystemStatus.textContent = `Analysis complete! Generated strategy: ${generatedStrategyName} (took ${elapsedSeconds}s)`;
                    intelligentSystemStatus.className = 'intelligent-system-status upload-success';

                } catch (saveError) {
                    console.error("[Main] Error processing or saving the generated strategy:", saveError);
                    intelligentSystemStatus.textContent = `Internal Error: Failed to process generated strategy. ${saveError.message}`;
                    intelligentSystemStatus.className = 'intelligent-system-status upload-error';
                }
            } else if (!analysisTimedOut) {
                // Failure: Timeout, analysis function error, or invalid return value
                const elapsedSeconds = ((Date.now() - startTime) / 1000).toFixed(1);

                let failureMsg = `Analysis failed to generate a valid strategy (took ${elapsedSeconds}s).`;
                if (analysisError) {
                    failureMsg = `Analysis failed: ${analysisError.message} (took ${elapsedSeconds}s)`;
                }
                console.warn(`[Main] ${failureMsg}`);
                intelligentSystemStatus.textContent = failureMsg;
                intelligentSystemStatus.className = 'intelligent-system-status upload-error';
            }

            // --- Final State Reset ---
            isIntelligentSystemAnalyzing = false;
            currentAnalysisStage = null;
            uploadIntelligentSystemButton.disabled = false;

            console.log("[Main] Analysis process finished.");
        }

        function compileIntelligentSystem(systemName) {
            // Check if already compiled
            if (compiledIntelligentSystems[systemName]) {
                return compiledIntelligentSystems[systemName];
            }

            // Get the system code
            const code = intelligentSystems[systemName];
            if (!code) {
                console.error(`Intelligent system not found: ${systemName}`);
                return null;
            }

            try {
                // Create a function that will return the analyzeStage function
                const compiledFunc = new Function(`
        ${code}
        
        // Return the analyzeStage function
        return typeof analyzeStage === 'function' ? analyzeStage : null;
    `);

                // Execute to get the analyzeStage function
                const analyzeStageFunc = compiledFunc();

                if (!analyzeStageFunc) {
                    throw new Error("analyzeStage function not found in the intelligent system");
                }

                // Cache the compiled function
                compiledIntelligentSystems[systemName] = analyzeStageFunc;

                return analyzeStageFunc;
            } catch (error) {
                console.error(`Error compiling intelligent system ${systemName}:`, error);
                return null;
            }
        }

        function loadSavedIntelligentSystems() {
            const data = localStorage.getItem('othelloIntelligentSystems');
            if (data) {
                try {
                    intelligentSystems = JSON.parse(data);
                } catch (error) {
                    console.error("Error loading intelligent systems:", error);
                    intelligentSystems = {};
                }
            } else {
                intelligentSystems = {};
            }
            compiledIntelligentSystems = {};
        }




        // --- Helper Functions ---
        function getPlayerName(player) {
            const sel = player === BLACK ? blackAISelect : whiteAISelect;
            const ctrlId = sel.value;

            if (ctrlId === 'human') return 'Human';

            if (ctrlId.startsWith('custom_')) {
                const fullName = ctrlId.replace('custom_', '');
                // Check if name is too long (adjust the 20 character limit as needed)
                if (fullName.length > 20) {
                    return fullName.substring(0, 18) + '...'; // Truncate with ellipsis
                }
                return fullName;
            }

            if (builtInStrategies[ctrlId]) {
                return ctrlId.charAt(0).toUpperCase() + ctrlId.slice(1);
            }

            return '?';
        }
        function displayMessage(msg, type = '') { statusElement.textContent = msg; statusElement.className = 'status ' + type; }
        function logMessage(msg) { moveLog.push(msg); updateGameLog(); }
        function logMove(row, col, player) {
            const pName = getPlayerName(player);
            const colorIndicator = player === BLACK ? "(B)" : "(W)"; // 색상 표시 추가
            const cL = String.fromCharCode(97 + col);
            const rN = row + 1;
            logMessage(`${pName}${colorIndicator}: ${cL}${rN}`); // 색상 표시 포함
        }
        function logPass(player) { const pName = getPlayerName(player); logMessage(`${pName} passes`); }
        function updateGameLog() { gameLogElement.innerHTML = moveLog.join('<br>'); gameLogElement.scrollTop = gameLogElement.scrollHeight; }
        function updateTimers() {
            const blackSeconds = (blackTimeUsed / 1000).toFixed(2);
            const whiteSeconds = (whiteTimeUsed / 1000).toFixed(2);
            blackTimerElement.textContent = `${blackSeconds}s`;
            whiteTimerElement.textContent = `${whiteSeconds}s`;
            if (blackTimeUsed >= 4000) {
                document.querySelector('.timer.black').classList.add('warning');
            } else {
                document.querySelector('.timer.black').classList.remove('warning');
            }
            if (whiteTimeUsed >= 4000) {
                document.querySelector('.timer.white').classList.add('warning');
            } else {
                document.querySelector('.timer.white').classList.remove('warning');
            }
            if (blackTimeUsed >= 4500) {
                document.querySelector('.timer.black').classList.add('danger');
            } else {
                document.querySelector('.timer.black').classList.remove('danger');
            }
            if (whiteTimeUsed >= 4500) {
                document.querySelector('.timer.white').classList.add('danger');
            } else {
                document.querySelector('.timer.white').classList.remove('danger');
            }
        }

        function checkTimeLimit(player, timeUsed) {
            if (timeUsed > MAX_AI_TIME_PER_GAME) {
                const playerName = player === BLACK ? "Black" : "White";
                const aiName = getPlayerName(player);
                logMessage(`${playerName} (${aiName}) exceeded the time limit of ${MAX_AI_TIME_PER_GAME / 1000}s!`);
                const opponent = player === BLACK ? WHITE : BLACK;
                const opponentName = opponent === BLACK ? "Black" : "White";
                logMessage(`${opponentName} wins by time forfeit!`);

                // 모든 빈 칸과 패배자의 말까지 승자의 색으로 바꿈
                const winningColor = opponent;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c] !== BLOCKED && board[r][c] !== winningColor) {
                            board[r][c] = winningColor;
                        }
                    }
                }
                updateBoardDisplay();
                endGame(opponent);
                return true;
            }
            return false;
        }

        // --- Tournament/Leaderboard Functions ---
        // recordGameResult, runTournament, playTournamentGame, updateLeaderboardDisplay, saveLeaderboardData, loadLeaderboardData
        // (Mostly same, ensure uses logMessage/updateGameLog correctly)
        function recordGameResult(blackName, whiteName, winner) { const s = countDiscs(); const match = { black: blackName, white: whiteName, winner: winner, date: new Date().toISOString(), score: s }; leaderboardData.matches.push(match);[blackName, whiteName].forEach(n => { if (!leaderboardData.results[n]) leaderboardData.results[n] = { wins: 0, losses: 0, draws: 0, totalGames: 0 }; }); if (winner === 1) { leaderboardData.results[blackName].wins++; leaderboardData.results[whiteName].losses++; } else if (winner === 2) { leaderboardData.results[blackName].losses++; leaderboardData.results[whiteName].wins++; } else { leaderboardData.results[blackName].draws++; leaderboardData.results[whiteName].draws++; } leaderboardData.results[blackName].totalGames++; leaderboardData.results[whiteName].totalGames++; saveLeaderboardData(); }

        function playTournamentGame() {
            return new Promise(resolve => {
                gameStartLogged = false;
                moveLog = [];

                startGame(true, currentTournamentStageConfig);

                const checkInterval = setInterval(() => {
                    if (!gameRunning) {
                        clearInterval(checkInterval);
                        const scores = countDiscs();
                        let winner = 0;

                        if (scores.black > scores.white) winner = 1;
                        else if (scores.white > scores.black) winner = 2;

                        const blackName = blackAISelect.options[blackAISelect.selectedIndex].text;
                        const whiteName = whiteAISelect.options[whiteAISelect.selectedIndex].text;

                        // Record the result in the leaderboard data
                        recordGameResult(blackName, whiteName, winner);

                        logMessage(`Result: ${blackName} ${scores.black} - ${whiteName} ${scores.white}`);
                        console.log(`Game result: ${blackName} ${scores.black} - ${whiteName} ${scores.white}`);
                        logMessage(`------ End of Game ------`);

                        // Update the leaderboard display immediately after each game
                        updateLeaderboardDisplay();

                        // Capture the game log for this game ***
                        const gameLog = generateHumanReadableLog(window.gameLogger);
                        tournamentGameLogs.push(gameLog);
                        console.log(`Game log captured for game ${tournamentGameLogs.length}`);

                        if (window.gameLogger) {
                            window.gameLogger.reset();
                        }

                        setTimeout(resolve, 10);
                    }
                }, 20);
            });
        }


        /**
         * Run a tournament between all available strategies
         * 수정: 토너먼트 완료 후 GameRollout에 게임 데이터가 제대로 로드되도록 보장
         */
        async function runTournament() {

            if (gameRunning || !confirm("Run tournament?")) return;

            isTournamentMode = true;

            console.log("=== Othello Tournament Start ===");
            tournamentStatusElement.textContent = 'Running...';
            runTournamentButton.disabled = true;
            moveLog = [];
            updateGameLog();

            // Reset game logger
            if (window.gameLogger) {
                window.gameLogger.reset();
            }

            // Initialize tournament logs array
            window.tournamentGameLogs = [];

            const allStrategies = [];

            Object.keys(builtInStrategies)
                .filter(k => k !== 'custom')
                .sort()
                .forEach(n => allStrategies.push({ id: n, name: n.charAt(0).toUpperCase() + n.slice(1) }));

            Object.keys(savedStrategies)
                .sort()
                .forEach(n => allStrategies.push({ id: `custom_${n}`, name: n }));

            if (allStrategies.length < 2) {
                tournamentStatusElement.textContent = 'Need >= 2 AIs';
                runTournamentButton.disabled = false;
                return;
            }

            const selectedIndex = parseInt(stageSelect.value);
            currentTournamentStageConfig = (selectedIndex >= 0 && selectedIndex < stages.length)
                ? stages[selectedIndex]
                : stages[0];

            console.log(`Tournament using stage: ${currentTournamentStageConfig.name}`);
            logMessage(`=== Tournament Start on Stage: ${currentTournamentStageConfig.name} ===`);

            const totalG = allStrategies.length * (allStrategies.length - 1);
            let played = 0;

            // Initialize fresh leaderboard data
            leaderboardData = { matches: [], results: {} };
            updateLeaderboardDisplay();

            tournamentStatusElement.textContent = `Running... (0/${totalG}) on ${currentTournamentStageConfig.name}`;

            for (let i = 0; i < allStrategies.length; i++) {
                for (let j = 0; j < allStrategies.length; j++) {
                    if (i === j) continue;

                    const p1S = allStrategies[i];
                    const p2S = allStrategies[j];

                    played++;
                    tournamentStatusElement.textContent = `Running... (${played}/${totalG}) on ${currentTournamentStageConfig.name}`;

                    logMessage(`\n===== Game ${played}/${totalG} =====`);
                    logMessage(`${p1S.name}(B) vs ${p2S.name}(W)`);
                    console.log(`Game ${played}: ${p1S.name} vs ${p2S.name}`);

                    await new Promise(r => setTimeout(r, 10));
                    blackAISelect.value = p1S.id;
                    whiteAISelect.value = p2S.id;

                    // Play the tournament game
                    await playTournamentGame();

                    // After each game, capture the current game log
                    const currentGameLog = generateHumanReadableLog(window.gameLogger);

                    // Add non-empty logs to the collection
                    if (currentGameLog && currentGameLog.trim() !== "") {
                        window.tournamentGameLogs.push(currentGameLog);
                    }

                    // 중요: 이전 게임 로그가 gameLogger.previousGames에 잘 저장되었는지 확인
                    console.log(`Game ${played} completed. previousGames count: ${window.gameLogger.previousGames.length}`);

                    await new Promise(r => setTimeout(r, 10));
                }
            }

            tournamentStatusElement.textContent = `Tournament Complete! (${totalG} games on ${currentTournamentStageConfig.name})`;
            runTournamentButton.disabled = false;
            currentTournamentStageConfig = null;
            isTournamentMode = false;
            logMessage(`=== Tournament Finished ===`);
            console.log("=== Othello Tournament Finished ===");

            // 토너먼트 완료 후 로드 과정 수정
            await new Promise(r => setTimeout(r, 800)); // 조금 더 긴 딜레이 적용

            // 토너먼트 로그 표시 및 GameRollout 업데이트
            const logInput = document.getElementById('log-input');
            if (logInput && window.tournamentGameLogs && window.tournamentGameLogs.length > 0) {
                console.log(`Displaying ${window.tournamentGameLogs.length} tournament game logs`);

                // Join all game logs with empty lines between them
                const combinedLog = window.tournamentGameLogs.join('\n\n');

                // Display in the textarea
                logInput.value = combinedLog;

                // Save the current log to the gameLogger property
                if (window.gameLogger) {
                    window.gameLogger.lastTournamentLog = combinedLog;
                }

                // 여기서 중요한 부분: previousGames 배열이 제대로 채워졌는지 확인
                console.log(`Tournament complete. Total games in previousGames: ${window.gameLogger.previousGames.length}`);

                // GameRollout 초기화 및 업데이트
                if (window.gameRollout && window.gameLogger.previousGames.length > 0) {
                    // 1. 현재 진행 중인 rollout 멈춤
                    window.gameRollout.stop();

                    // 2. 게임 경계 분석 강제 실행
                    window.gameRollout.analyzeGameBoundaries();

                    // 3. 현재 상태를 처음 게임의 첫 번째 수로 설정
                    // window.gameRollout.jumpToMove(0);
                    const lastGameIndex = window.gameLogger.previousGames.length - 1;
                    window.gameRollout.currentGameIndex = lastGameIndex;
                    window.gameRollout.currentMoveIndex = -1; // Turn 0로 설정

                    if (window.gameLogger.previousGames.length > 0) {
                        const selectedGame = window.gameLogger.previousGames[lastGameIndex];
                        let stageConfig = null;

                        if (selectedGame && selectedGame.metadata && selectedGame.metadata.stage) {
                            const stageName = selectedGame.metadata.stage;
                            stageConfig = stages.find(s => s.name === stageName) || stages[0];
                        }

                        const initialBoard = createInitialBoard(stageConfig);
                        window.gameRollout.gameBoard.setBoard(initialBoard);

                        // 추가: 선택된 게임의 로그 표시
                        const logInput = document.getElementById('log-input');
                        if (logInput) {
                            // Use stored log text if available
                            if (selectedGame.logText) {
                                logInput.value = selectedGame.logText;
                            }
                            // If no log text, generate from metadata
                            else if (selectedGame.metadata) {
                                logInput.value = `Game ${lastGameIndex + 1}: ${selectedGame.metadata.blackStrategy}(B) vs ${selectedGame.metadata.whiteStrategy}(W) on ${selectedGame.metadata.stage}`;
                            } else {
                                logInput.value = `Game ${lastGameIndex + 1} (details not available)`;
                            }
                        }

                    }

                    // 4. UI 컨트롤 업데이트
                    updateRolloutControls();

                    console.log("GameRollout successfully initialized with tournament data");
                } else {
                    console.warn("Cannot initialize GameRollout: gameLogger.previousGames is empty or GameRollout not available");
                }
            } else {
                console.warn("Cannot display tournament logs: either log input or tournament logs missing");
            }

            // 토너먼트 로그 영역으로 스크롤
            try {
                const rolloutControls = document.querySelector('.rollout-controls');
                if (rolloutControls) {
                    rolloutControls.scrollIntoView({ behavior: 'smooth' });
                }
            } catch (e) {
                console.warn("Failed to scroll to rollout controls:", e);
            }
        }

        // --- Enhanced updateLeaderboardDisplay function (unchanged, included for completeness) ---
        function updateLeaderboardDisplay() {
            leaderboardBody.innerHTML = '';

            const lb = Object.keys(leaderboardData.results).map(n => {
                const s = leaderboardData.results[n];
                return {
                    name: n,
                    wins: s.wins,
                    losses: s.losses,
                    draws: s.draws,
                    totalGames: s.totalGames,
                    winRate: s.totalGames > 0 ? ((s.wins + s.draws * 0.5) / s.totalGames * 100).toFixed(1) : 0
                };
            });

            lb.sort((a, b) => b.winRate - a.winRate || b.wins - a.wins);

            lb.forEach((entry, idx) => {
                const row = document.createElement('tr');
                row.innerHTML = `<td>${idx + 1}</td><td>${entry.name}</td><td>${entry.winRate}%</td><td>${entry.wins}</td><td>${entry.losses}</td><td>${entry.draws}</td><td>${entry.totalGames}</td>`;
                leaderboardBody.appendChild(row);
            });
        }

        function saveLeaderboardData() { localStorage.setItem('othelloLeaderboard', JSON.stringify(leaderboardData)); }
        function loadLeaderboardData() { const d = localStorage.getItem('othelloLeaderboard'); if (d) { try { leaderboardData = JSON.parse(d); } catch (e) { console.error("Err load LB", e); leaderboardData = { matches: [], results: {} }; } } else { leaderboardData = { matches: [], results: {} }; } updateLeaderboardDisplay(); }

        function resetTournament() {
            if (gameRunning) {
                alert("Cannot reset tournament data while a game is running.");
                return;
            }

            if (confirm("Are you sure you want to reset all tournament records?")) {
                // Reset the leaderboard data
                leaderboardData = { matches: [], results: {} };

                // Save the empty data to localStorage
                saveLeaderboardData();

                // Update the UI
                updateLeaderboardDisplay();

                // Show confirmation message
                tournamentStatusElement.textContent = "Tournament records have been reset.";

                console.log("Tournament records reset.");
            }
        }



        // Setup rollout controls in GameUI
        function setupRolloutControls() {
            // Get rollout button elements
            const playBtn = document.getElementById('rollout-play');
            const pauseBtn = document.getElementById('rollout-pause');
            const stopBtn = document.getElementById('rollout-stop');
            const prevBtn = document.getElementById('rollout-prev');
            const nextBtn = document.getElementById('rollout-next');
            const prevGameBtn = document.getElementById('rollout-prev-game');
            const nextGameBtn = document.getElementById('rollout-next-game');
            const speedSlider = document.getElementById('rollout-speed');
            const moveSlider = document.getElementById('rollout-moves');

            // Event listeners

            if (prevGameBtn) {
                prevGameBtn.addEventListener('click', () => {
                    if (window.gameRollout) {
                        window.gameRollout.previousGame();
                        updateRolloutControls();
                    }
                });
            }

            if (nextGameBtn) {
                nextGameBtn.addEventListener('click', () => {
                    if (window.gameRollout) {
                        window.gameRollout.nextGame();
                        updateRolloutControls();
                    }
                });
            }

            if (playBtn) {
                playBtn.addEventListener('click', () => {
                    console.log("Play button clicked");
                    window.gameRollout.start(0);
                    updateRolloutControls();
                });
            }

            if (pauseBtn) {
                pauseBtn.addEventListener('click', () => {
                    window.gameRollout.pause();
                    updateRolloutControls();
                });
            }

            if (stopBtn) {
                stopBtn.addEventListener('click', () => {
                    window.gameRollout.stop();
                    updateRolloutControls();
                });
            }

            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    window.gameRollout.previous();
                    updateRolloutControls();
                });
            }

            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    window.gameRollout.next();
                    updateRolloutControls();
                });
            }

            if (speedSlider) {
                // Update the slider's max attribute to 10
                speedSlider.max = 10;

                speedSlider.addEventListener('input', (e) => {
                    // Get the current value (1-10)
                    const value = parseInt(e.target.value);

                    // Calculate speed based on the 10-step scale
                    // Step 1: 2000ms (2 seconds)
                    // Step 2: 1000ms (1 second)
                    // Step 3: 500ms (0.5 seconds)
                    // Each subsequent step cuts the time in half
                    let speed = 2000 / Math.pow(2, value - 1);

                    // Set a minimum speed limit (Step 10 would be ~3.9ms)
                    speed = Math.max(speed, 4);

                    // Apply the new speed
                    window.gameRollout.setSpeed(speed);

                    // Optionally log the current speed setting
                    console.log(`Speed set to ${speed.toFixed(2)}ms per move (level ${value}/10)`);
                });
            }

            if (moveSlider) {
                moveSlider.addEventListener('input', (e) => {
                    const moveIndex = parseInt(e.target.value, 10);
                    window.gameRollout.jumpToMove(moveIndex);
                    updateRolloutControls();
                });
            }

            // Setup log save/load controls
            setupLogControls();

            // Update rollout controls initial state
            updateRolloutControls();
        }

        function updateRolloutControls() {
            if (!window.gameRollout) return;

            let currentTurn = window.gameRollout.currentMoveIndex + 1;
            if (window.gameRollout.currentMoveIndex === -1) {
                currentTurn = 0;
            }
            let totalTurns = 0;
            let gameIndex = window.gameRollout.currentGameIndex;
            let totalGames = 1;

            if (window.gameLogger && window.gameLogger.previousGames &&
                window.gameLogger.previousGames.length > 0) {

                totalGames = window.gameLogger.previousGames.length;

                if (gameIndex < totalGames) {
                    const currentGame = window.gameLogger.previousGames[gameIndex];
                    totalTurns = currentGame.moves ? currentGame.moves.length : 0;
                }
            }

            const progressElem = document.getElementById('rollout-progress');
            const gameCounterElem = document.getElementById('game-counter');

            if (progressElem) {
                progressElem.textContent = `Turn ${currentTurn}/${totalTurns}`;
            }

            if (gameCounterElem) {
                gameCounterElem.textContent = `(Game ${gameIndex + 1}/${totalGames})`;
            }

            const moveSlider = document.getElementById('rollout-moves');
            if (moveSlider) {
                moveSlider.min = -1;
                moveSlider.max = Math.max(0, totalTurns - 1);
                moveSlider.value = window.gameRollout.currentMoveIndex;
            }

            const playBtn = document.getElementById('rollout-play');
            const pauseBtn = document.getElementById('rollout-pause');
            const prevGameBtn = document.getElementById('rollout-prev-game');
            const nextGameBtn = document.getElementById('rollout-next-game');

            if (playBtn) playBtn.disabled = window.gameRollout.isRolling;
            if (pauseBtn) pauseBtn.disabled = !window.gameRollout.isRolling;

            if (prevGameBtn) {
                prevGameBtn.disabled = gameIndex <= 0;
            }

            if (nextGameBtn) {
                nextGameBtn.disabled = gameIndex >= totalGames - 1;
            }
        }


        // Get information about the current game being displayed
        function getGameInformation() {
            if (!window.gameRollout || !window.gameLogger) {
                return "Game Info Unavailable";
            }

            const logs = window.gameLogger.getLogs();
            if (!logs || !logs.moves || logs.moves.length === 0) {
                return "No Game Data";
            }

            let blackName = "Black";
            let whiteName = "White";
            let stageName = "Unknown";

            // Try to get player names and stage info from the UI
            try {
                const blackSelect = document.getElementById('black-ai');
                const whiteSelect = document.getElementById('white-ai');
                const stageSelect = document.getElementById('stageSelect');

                if (blackSelect && blackSelect.selectedIndex >= 0) {
                    blackName = blackSelect.options[blackSelect.selectedIndex].text;
                }

                if (whiteSelect && whiteSelect.selectedIndex >= 0) {
                    whiteName = whiteSelect.options[whiteSelect.selectedIndex].text;
                }

                if (stageSelect && stageSelect.selectedIndex >= 0) {
                    stageName = stageSelect.options[stageSelect.selectedIndex].text;
                    // Remove numeric prefix (e.g., "1: Standard 8x8" → "Standard 8x8")
                    stageName = stageName.replace(/^\d+:\s*/, '');
                }
            } catch (e) {
                console.warn("Failed to get player/stage info", e);
            }

            // Get game-specific information from tournament status
            try {
                const tournamentStatus = document.getElementById('tournament-status');
                if (tournamentStatus && tournamentStatus.textContent.includes("games on")) {
                    // Extract stage name from tournament status
                    const match = tournamentStatus.textContent.match(/games on ([^)]+)/);
                    if (match && match[1]) {
                        stageName = match[1].trim();
                    }
                }
            } catch (e) {
                console.warn("Failed to get stage info from tournament status", e);
            }

            // Return formatted game information
            return `${stageName}: ${blackName} (B) vs ${whiteName} (W)`;
        }

        /**
         * Sets up event handlers for log saving and loading functionality
         * Provides mechanisms to save all game logs into a single file
         */
        function setupLogControls() {
            const saveBtn = document.getElementById('save-log');
            const logInput = document.getElementById('log-input');

            if (saveBtn) {
                saveBtn.addEventListener('click', () => {
                    // Check if logger is initialized
                    if (!window.gameLogger) {
                        alert('Game logger is not initialized.');
                        return;
                    }

                    console.log("Save button clicked");

                    // Get all game data: previous games and current game
                    const previousGames = window.gameLogger.previousGames || [];
                    const currentLogText = logInput.value;

                    // Log the number of games being saved
                    console.log(`Saving ${previousGames.length} previous games plus current game`);

                    // Save all games as a combined log file
                    saveAllGameLogs(previousGames, currentLogText);
                });
            }

            // Add drag & drop functionality for the textarea (optional)
            if (logInput) {
                logInput.addEventListener('dragover', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                });
            }
        }

        /**
         * Saves all game logs (previous games and current game) into files
         * @param {Array} previousGames - Array of previous game data objects
         * @param {string} currentLogText - Current game log text (from text area)
         */
        function saveAllGameLogs(previousGames, currentLogText) {
            try {
                // Game logs collection
                const gameTexts = [];

                // 1. Process previous games data
                if (previousGames && previousGames.length > 0) {
                    previousGames.forEach((game, index) => {
                        // Convert game object to text format
                        const gameText = convertGameToText(game, index);
                        if (gameText && gameText.trim() !== "") {
                            gameTexts.push(gameText);
                        }
                    });
                }

                // 2. Add current game text if it's not already in previous games
                // and is not the "No game log" placeholder
                if (currentLogText &&
                    currentLogText.trim() !== "" &&
                    !currentLogText.includes("No game log data available")) {

                    // Check if the current log text is already included in previous games
                    const isAlreadyIncluded = gameTexts.some(text =>
                        text.trim() === currentLogText.trim() ||
                        currentLogText.includes(text.trim())
                    );

                    if (!isAlreadyIncluded) {
                        gameTexts.push(currentLogText);
                    }
                }

                // Handle case when no logs are available
                if (gameTexts.length === 0) {
                    console.warn('No game logs available to save.');
                    return;
                }

                // Generate timestamp for the filename
                const now = new Date();
                const timestamp = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}-${now.getMinutes().toString().padStart(2, '0')}-${now.getSeconds().toString().padStart(2, '0')}`;

                // 3. Save text format logs
                const textFileName = `OthelloGames_${timestamp}.txt`;
                const textBlob = new Blob([gameTexts.join('\n\n')], { type: 'text/plain' });
                const textDownloadLink = document.createElement('a');
                textDownloadLink.href = URL.createObjectURL(textBlob);
                textDownloadLink.download = textFileName;
                textDownloadLink.style.display = 'none';
                document.body.appendChild(textDownloadLink);
                textDownloadLink.click();

                // Small delay before next download
                setTimeout(() => {
                    // 4. Save JSON format logs
                    if (previousGames && previousGames.length > 0) {
                        const jsonFileName = `othello_games_log_${timestamp}.json`;
                        const jsonBlob = new Blob([JSON.stringify(previousGames)], { type: 'application/json' });
                        const jsonDownloadLink = document.createElement('a');
                        jsonDownloadLink.href = URL.createObjectURL(jsonBlob);
                        jsonDownloadLink.download = jsonFileName;
                        jsonDownloadLink.style.display = 'none';
                        document.body.appendChild(jsonDownloadLink);
                        jsonDownloadLink.click();
                        document.body.removeChild(jsonDownloadLink);

                        // Show non-blocking notification 
                        const statusElement = document.getElementById('status');
                        if (statusElement) {
                            const originalStatus = statusElement.textContent;
                            const originalBg = statusElement.style.backgroundColor;

                            // Show success message
                            statusElement.textContent = `Logs saved as ${textFileName} and ${jsonFileName}`;
                            statusElement.style.backgroundColor = '#4CAF50';

                            // Restore original status after 3 seconds
                            setTimeout(() => {
                                statusElement.textContent = originalStatus;
                                statusElement.style.backgroundColor = originalBg;
                            }, 3000);
                        }
                    }

                    // Clean up text download link
                    document.body.removeChild(textDownloadLink);

                    // Copy to clipboard
                    const logInput = document.getElementById('log-input');
                    if (logInput) {
                        logInput.value = gameTexts.join('\n\n');
                        logInput.select();
                        try {
                            document.execCommand('copy');
                            console.log("Game logs copied to clipboard");
                        } catch (e) {
                            console.error('Failed to copy to clipboard:', e);
                        }
                    }
                }, 500); // 500ms delay between downloads

            } catch (e) {
                console.error('Error saving game logs:', e);
                const statusElement = document.getElementById('status');
                if (statusElement) {
                    statusElement.textContent = 'Failed to save game logs. See console for details.';
                    statusElement.style.backgroundColor = '#f44336';
                }
            }
        }


        // /**
        //  * Saves all game logs (previous games and current game) into a single file
        //  * @param {Array} previousGames - Array of previous game data objects
        //  * @param {string} currentLogText - Current game log text (from text area)
        //  */
        // function saveAllGameLogs(previousGames, currentLogText) {
        //     try {
        //         // Game logs collection
        //         const gameTexts = [];

        //         // 1. Process previous games data
        //         if (previousGames && previousGames.length > 0) {
        //             previousGames.forEach((game, index) => {
        //                 // Convert game object to text format
        //                 const gameText = convertGameToText(game, index);
        //                 if (gameText && gameText.trim() !== "") {
        //                     gameTexts.push(gameText);
        //                 }
        //             });
        //         }

        //         // 2. Add current game text if it's not already in previous games
        //         // and is not the "No game log" placeholder
        //         if (currentLogText &&
        //             currentLogText.trim() !== "" &&
        //             !currentLogText.includes("No game log data available")) {

        //             // Check if the current log text is already included in previous games
        //             const isAlreadyIncluded = gameTexts.some(text =>
        //                 text.trim() === currentLogText.trim() ||
        //                 currentLogText.includes(text.trim())
        //             );

        //             if (!isAlreadyIncluded) {
        //                 gameTexts.push(currentLogText);
        //             }
        //         }

        //         // Handle case when no logs are available
        //         if (gameTexts.length === 0) {
        //             alert('No game logs available to save.');
        //             return;
        //         }

        //         // Combine all game texts with empty lines between them
        //         const combinedLog = gameTexts.join('\n\n');

        //         // Generate timestamp for the filename
        //         const now = new Date();
        //         const timestamp = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}-${now.getMinutes().toString().padStart(2, '0')}-${now.getSeconds().toString().padStart(2, '0')}`;

        //         // Simple filename format with timestamp
        //         const fileName = `OthelloGames_${timestamp}.txt`;

        //         // Create blob and download link
        //         const textBlob = new Blob([combinedLog], { type: 'text/plain' });
        //         const downloadLink = document.createElement('a');
        //         downloadLink.href = URL.createObjectURL(textBlob);
        //         downloadLink.download = fileName;
        //         downloadLink.style.display = 'none';

        //         // Trigger download
        //         document.body.appendChild(downloadLink);
        //         downloadLink.click();
        //         document.body.removeChild(downloadLink);

        //         // Copy to clipboard
        //         logInput.value = combinedLog;
        //         logInput.select();
        //         try {
        //             document.execCommand('copy');
        //             alert(`Game logs saved as ${fileName} and copied to clipboard.`);
        //         } catch (e) {
        //             console.error('Failed to copy to clipboard:', e);
        //             alert(`Game logs saved as ${fileName}.`);
        //         }

        //     } catch (e) {
        //         console.error('Error saving game logs:', e);
        //         alert('Failed to save game logs. See console for details.');
        //     }
        // }




        /**
         * Extracts stage name from game log text
         * @param {string} logText - Game log text
         * @returns {string} Extracted stage name or default value
         */
        function extractStageName(logText) {
            if (!logText) return "Unknown_Stage";

            const stageMatch = logText.match(/Game started:.*?on Stage: (.+?)(?:\n|$)/);
            if (stageMatch && stageMatch[1]) {
                return stageMatch[1].trim();
            }

            // Fallback to UI if no match in log
            try {
                const stageSelect = document.getElementById('stageSelect');
                if (stageSelect && stageSelect.selectedIndex >= 0) {
                    return stageSelect.options[stageSelect.selectedIndex].text.replace(/^\d+:\s*/, '');
                }
            } catch (e) {
                console.warn("Failed to get stage name from UI:", e);
            }

            return "Unknown_Stage";
        }

        /**
         * Extracts player names from game log text
         * @param {string} logText - Game log text
         * @returns {Object} Object with black and white player names
         */
        function extractPlayerNames(logText) {
            if (!logText) return { black: "Black", white: "White" };

            const playerMatch = logText.match(/Game started: (.+?)\(B\) vs (.+?)\(W\)/);
            if (playerMatch && playerMatch.length >= 3) {
                return {
                    black: playerMatch[1].trim(),
                    white: playerMatch[2].trim()
                };
            }

            // Fallback to UI if no match in log
            try {
                const blackSelect = document.getElementById('black-ai');
                const whiteSelect = document.getElementById('white-ai');

                return {
                    black: (blackSelect && blackSelect.selectedIndex >= 0) ?
                        blackSelect.options[blackSelect.selectedIndex].text : "Black",
                    white: (whiteSelect && whiteSelect.selectedIndex >= 0) ?
                        whiteSelect.options[whiteSelect.selectedIndex].text : "White"
                };
            } catch (e) {
                console.warn("Failed to get player names from UI:", e);
                return { black: "Black", white: "White" };
            }
        }


        /**
         * Helper function to convert a game object to human-readable text
         * @param {Object} game - Game object from previousGames array
         * @param {number} gameIndex - Index of the game
         * @param {Object} gameResult - Game result object from gameResults array
         * @returns {string} Human-readable game log
         */
        function convertGameToText(game) {
            try {
                if (!game || !game.moves || game.moves.length === 0) {
                    return "Invalid game data";
                }

                let blackName = "Black";
                let whiteName = "White";
                let stageName = "Unknown Stage";

                if (game.metadata) {
                    if (game.metadata.blackStrategy) blackName = game.metadata.blackStrategy;
                    if (game.metadata.whiteStrategy) whiteName = game.metadata.whiteStrategy;
                    if (game.metadata.stage) stageName = game.metadata.stage;
                }

                let gameLog = `Game started: ${blackName}(B) vs ${whiteName}(W) on Stage: ${stageName}\n`;

                const colLabels = 'abcdefghijklmnopqrstuvwxyz';
                game.moves.forEach(move => {
                    if (move && move.player && move.position) {
                        const playerName = move.player === 1 ? blackName : whiteName;
                        const colorIndicator = move.player === 1 ? "(B)" : "(W)"; // 색상 표시 추가
                        const col = colLabels[move.position.col];
                        const row = move.position.row + 1;
                        gameLog += `${playerName}${colorIndicator}: ${col}${row}\n`; // 색상 표시 포함
                    }
                });

                if (game.metadata && game.metadata.blackScore !== undefined &&
                    game.metadata.whiteScore !== undefined) {
                    const blackScore = game.metadata.blackScore;
                    const whiteScore = game.metadata.whiteScore;

                    gameLog += `Game over: Final score ${blackScore}-${whiteScore}\n`;

                    if (blackScore > whiteScore) {
                        gameLog += "Black wins!";
                    } else if (whiteScore > blackScore) {
                        gameLog += "White wins!";
                    } else {
                        gameLog += "It's a tie!";
                    }
                } else if (game.boards && game.boards.length > 0) {

                    const finalBoard = game.boards[game.boards.length - 1];
                    let blackCount = 0;
                    let whiteCount = 0;

                    for (let r = 0; r < finalBoard.length; r++) {
                        for (let c = 0; c < finalBoard[r].length; c++) {
                            if (finalBoard[r][c] === 1) blackCount++;
                            else if (finalBoard[r][c] === 2) whiteCount++;
                        }
                    }

                    gameLog += `Game over: Final score ${blackCount}-${whiteCount}\n`;

                    if (blackCount > whiteCount) {
                        gameLog += "Black wins!";
                    } else if (whiteCount > blackCount) {
                        gameLog += "White wins!";
                    } else {
                        gameLog += "It's a tie!";
                    }
                } else {
                    gameLog += "Game over";
                }

                return gameLog;
            } catch (e) {
                console.error("Error converting game to text:", e);
                return "Error generating game log";
            }
        }



        /**
         * Generate human-readable log for the current game
         * Only used for the active game that hasn't been completed yet
         * @param {GameLogger} gameLogger - The game logger instance
         * @return {string} Formatted log text
         */
        function generateHumanReadableLog(gameLogger) {
            try {
                const logs = gameLogger.getLogs();
                if (!logs || !logs.moves || logs.moves.length === 0) {
                    return "No game log data available.";
                }

                // Get current player strategies and stage from UI
                let blackName = "Black";
                let whiteName = "White";
                let stageName = "Unknown Stage";

                try {
                    const blackSelect = document.getElementById('black-ai');
                    const whiteSelect = document.getElementById('white-ai');

                    if (blackSelect && blackSelect.selectedIndex >= 0) {
                        blackName = blackSelect.options[blackSelect.selectedIndex].text;
                    }

                    if (whiteSelect && whiteSelect.selectedIndex >= 0) {
                        whiteName = whiteSelect.options[whiteSelect.selectedIndex].text;
                    }

                    if (currentStage && currentStage.name) {
                        stageName = currentStage.name;
                    }
                } catch (e) {
                    console.warn("Could not get names from UI:", e);
                }

                // Create game header
                let textLog = `Game started: ${blackName}(B) vs ${whiteName}(W) on Stage: ${stageName}\n`;

                // Add moves
                const colLabels = 'abcdefghijklmnopqrstuvwxyz';
                logs.moves.forEach(move => {
                    if (move && move.player && move.position) {
                        const playerName = move.player === 1 ? blackName : whiteName;
                        const colorIndicator = move.player === 1 ? "(B)" : "(W)"; // 색상 표시 추가

                        if (typeof move.position === 'object' &&
                            typeof move.position.row === 'number' &&
                            typeof move.position.col === 'number') {
                            const col = colLabels[move.position.col];
                            const row = move.position.row + 1;
                            textLog += `${playerName}${colorIndicator}: ${col}${row}\n`; // 색상 표시 포함
                        }
                    }
                });

                // Add result if game is over
                if (gameOver && logs.boards && logs.boards.length > 0) {
                    const finalBoard = logs.boards[logs.boards.length - 1];
                    let blackCount = 0;
                    let whiteCount = 0;

                    for (let r = 0; r < finalBoard.length; r++) {
                        for (let c = 0; c < finalBoard[r].length; c++) {
                            if (finalBoard[r][c] === 1) blackCount++;
                            else if (finalBoard[r][c] === 2) whiteCount++;
                        }
                    }

                    textLog += `Game over: Final score ${blackCount}-${whiteCount}\n`;

                    if (blackCount > whiteCount) {
                        textLog += "Black wins!";
                    } else if (whiteCount > blackCount) {
                        textLog += "White wins!";
                    } else {
                        textLog += "It's a tie!";
                    }
                }

                return textLog;
            } catch (e) {
                console.error("Error generating human readable log:", e);
                return "Error generating game log";
            }
        }


        // --- Initial Setup ---
        function populateStageSelect() { stages.forEach((stage, idx) => { const opt = document.createElement('option'); opt.value = idx; opt.textContent = `${idx + 1}: ${stage.name}`; stageSelect.appendChild(opt); }); }
        function initializeApp() {
            console.log("Initializing Othello Arena w/ Stages...");
            populateStageSelect();
            loadSavedStrategies();
            loadSavedIntelligentSystems(); // Add this line
            updateAISelectors();
            loadLeaderboardData();

            // Create GameLogger instance and load from local storage
            window.gameLogger = new GameLogger();
            gameLogger.loadFromLocalStorage();

            // Create IntelligentSystemInterface instance
            window.systemInterface = new IntelligentSystemInterface(gameLogger, {
                // Board controller functions
                getBoard: () => board,
                resetBoard: () => initializeBoard(currentStage, true)
            });

            // Initialize GameRollout
            window.gameRollout = new GameRollout(
                { // Board controller - provides board update functions
                    setBoard: (boardState) => {
                        board = boardState;
                        updateBoardDisplay();
                    },
                    updatePlayerIndicator: (player) => {
                        // Update current player indicator (optional)
                        // In actual implementation, find and update UI elements
                    },
                    highlightCell: (row, col) => {
                        // Highlight move position (optional)
                        // In actual implementation, apply highlight style to the cell
                    }
                },
                window.gameLogger
            );


            if (stages.length > 0) {
                initializeBoard(stages[0], true);
            } else {
                initializeBoard(null, true);
            }

            // Add event listeners
            boardElement.addEventListener('click', handleHumanMove);
            startButton.addEventListener('click', () => {
                const idx = stageSelect.value;
                if (idx >= 0 && idx < stages.length)
                    startGame(false, stages[idx]);
                else
                    alert("Select Stage");
            });
            resetButton.addEventListener('click', resetGame);
            setupRolloutControls();
            saveStrategyButton.addEventListener('click', saveStrategy);
            clearEditorButton.addEventListener('click', clearEditor);
            uploadStrategiesButton.addEventListener('click', uploadStrategyFiles);
            runTournamentButton.addEventListener('click', runTournament);
            document.getElementById('reset-tournament-btn').addEventListener('click', resetTournament);


            // Add this event listener for intelligent system upload
            uploadIntelligentSystemButton.addEventListener('click', uploadIntelligentSystem);

            // Add stage change handling for intelligent system analysis
            stageSelect.addEventListener('change', () => {
                const idx = stageSelect.value;
                if (idx < 0 || idx >= stages.length) return;
                gameRunning = false;
                if (gameLoopTimeout) clearTimeout(gameLoopTimeout);
                gameLoopTimeout = null;
                aiThinking = false;
                initializeBoard(stages[idx], true);
            });

            console.log("Othello Arena Initialized.");
        }

        // --- Start the App ---
        document.addEventListener('DOMContentLoaded', initializeApp);

    </script>


</body></html>